class Engine{constructor(){this.input=null,this.screen=null,this.context=null,this.manager=null,this.music=null,this.timer=null}setInput(input){this.input=input}setScreen(screen){this.screen=screen}setContext(context){this.context=context}setSceneManager(manager){this.manager=manager}setMusic(music){this.music=music}setTimer(timer){this.timer=timer}execute(scene){this.input.setScreen(this.screen),this.context.setScreen(this.screen),this.screen.init(),this.context.init(),this.input.init(),this.manager.replaceScene(scene),this.main()}main(){}}class EngineBuilder{makeEngine(){}makeInput(){}makeScreen(){}makeContext(){}makeImageManager(){}makeMusic(){}makeMusicManager(){}makeTimer(){}makeSceneManager(){}build(){const engine=this.makeEngine();engine.setInput(this.makeInput()),engine.setScreen(this.makeScreen());const context=this.makeContext();context.setImageManager(this.makeImageManager()),engine.setContext(context);const music=this.makeMusic();return music.setMusicManager(this.makeMusicManager()),engine.setMusic(music),engine.setSceneManager(this.makeSceneManager()),engine.setTimer(this.makeTimer()),engine}}class GameEvent{constructor(){this.op=null}setEventOperator(op){this.op=op}init(){}destruct(){}update(dt){return!0}render(ctx){}}class NamedEvent extends GameEvent{constructor(name){super(),this.name=name}getName(){return this.name}}class EventManager{constructor(){BaseUtil.implementsOf(this,IEventRegister)&&(EventManager.it=this)}getRunningEvents(){}removeEvents(removes){}update(dt){const removes=[];for(const it of this.getRunningEvents())it.update(dt)&&removes.push(it);this.removeEvents(removes)}render(ctx){for(const it of this.getRunningEvents())it.render(ctx)}}EventManager.it=null;class StageEvent extends GameEvent{constructor(){super(),this.stage=null}setStage(stage){this.stage=stage}}class EventBuilder{constructor(){this.imageBuilder=null}setImageBuilder(image){this.imageBuilder=image}build(json){}}class Input{constructor(){this.screen=null,Input.key=BaseUtil.implementsOf(this,IKey)?this:null,Input.mouse=BaseUtil.implementsOf(this,IMouse)?this:null}setScreen(screen){this.screen=screen}init(){}update(){}}Input.key=null,Input.mouse=null;class Context{constructor(){this.screen=null,this.image=null}setScreen(screen){this.screen=screen}setImageManager(imageManager){this.image=imageManager}init(){}preRendering(){}postRendering(){}measureText(text,size,font){}fillText(text,x,y,anchorX,anchorY,size,color,font){}strokeLine(sx,sy,ex,ey,color,lineWidth){}strokeCircle(x,y,radius,startAngle,endAngle,anticlockwise,color,lineWidth){}strokeRect(x,y,width,height,color,lineWidth){}fillRect(x,y,width,height,color,lineWidth){}drawImage(imageID,x,y,width,height,srcX,srcY,srcW,srcH){}}class GameImage{setSize(width,height){}setImageID(imageID){}getImageID(){}getWidth(){}getHeight(){}getSourceOffsetX(){}getSourceOffsetY(){}getSourceWidth(){}getSourceHeight(){}init(){}update(dt){}render(ctx,x,y){}}class Music{constructor(){this.music=null,Music.it=this}setMusicManager(musicManager){this.music=musicManager}playSE(musicID){}playBGM(musicID){}pauseBGM(){}resumeBGM(){}stopBGM(){}}Music.it=null;class ResourceManager{constructor(root){this.root=root,BaseUtil.implementsOf(this,IImageManager)&&(ResourceManager.image=this),BaseUtil.implementsOf(this,IMusicManager)&&(ResourceManager.music=this)}load(filePath){}unload(id){}reload(){}getPath(id){}}ResourceManager.image=null,ResourceManager.music=null;class Layer{constructor(){this.x=0,this.y=0,this.z=0,this.width=0,this.height=0}setPosition(x,y,z){this.x=x,this.y=y,this.z=z}setSize(width,height){this.width=width,this.height=height}init(){}update(dt){}render(ctx){}}class Scene{init(){}update(dt){}render(ctx){}}class SceneManager{constructor(){SceneManager.it=this}getScene(){}pushScene(scene){scene.init()}popScene(){}replaceScene(scene){this.popScene(),this.pushScene(scene)}update(dt){this.getScene().update(dt)}render(ctx){this.getScene().render(ctx)}}SceneManager.it=null;class GameScreen{constructor(width,height){this.gameSize=1,this.width=width,this.height=height,GameScreen.it=this}init(){}getTarget(){}getCanvas(){}}GameScreen.it=null;class AI{constructor(){this.entity=null}setEntity(entity){this.entity=entity}init(){}update(dt){}apply(dt){}}class State{constructor(){this.entity=null,this.ai=null,this.canRendering=!1}setEntity(entity){this.entity=entity}setAI(ai){this.ai=ai}init(){}update(dt){}apply(dt){}render(ctx,shiftX=0,shiftY=0){}}class StateAI extends AI{getState(){}getStateID(){}setState(state,id){}changeState(id){this.getState().setEntity(this.entity),this.getState().setAI(this),this.getState().init()}update(dt){null!==this.getState()&&this.getState().update(dt)}apply(dt){return null!==this.getState()&&this.getState().apply(dt)}}class Background{init(){}update(dt){}render(ctx,shiftX,shiftY,screenWidth,screenHeight){}}class Camera{constructor(){this.cameraX=0,this.cameraY=0,this.baseX=0,this.baseY=0,this.screenWidth=0,this.screenHeight=0,this.maxWidth=0,this.maxHeight=0}setScreenSize(screenWidth,screenHeight){this.screenWidth=screenWidth,this.screenHeight=screenHeight}setMaxSize(maxWidth,maxHeight){this.maxWidth=maxWidth,this.maxHeight=maxHeight}init(x,y){}update(x,y,dt){}}class DelegateCamera extends Camera{constructor(baseCamera){super(),this.baseCamera=baseCamera}getBaseCamera(){return this.baseCamera}setScreenSize(screenWidth,screenHeight){super.setScreenSize(screenWidth,screenHeight),this.baseCamera.setScreenSize(screenWidth,screenHeight)}setMaxSize(maxWidth,maxHeight){super.setMaxSize(maxWidth,maxHeight),this.baseCamera.setMaxSize(maxWidth,maxHeight)}init(x,y){this.baseCamera.init(x,y),this.cameraX=this.baseCamera.cameraX,this.cameraY=this.baseCamera.cameraY}update(x,y,dt){this.baseCamera.update(x,y,dt)}}class Entity{constructor(){this.x=0,this.y=0,this.z=0,this.width=0,this.height=0,this.stage=null}setStage(stage){this.stage=stage}setPosition(x,y,z=this.z){this.x=x,this.y=y,this.z=z}setSize(width,height){this.width=width,this.height=height}init(){}update(dt){}render(ctx,shiftX=0,shiftY=0){}}class ImagedEntity extends Entity{constructor(){super(),this.image=null}setImage(image){this.image=image}getImage(){return this.image}setSize(width,height){super.setSize(width,height),null!==this.image&&this.image.setSize(width,height)}init(){null!==this.image&&this.image.init()}update(dt){null!==this.image&&this.image.update(dt)}render(ctx,shiftX=0,shiftY=0){null!==this.image&&this.image.render(ctx,this.x+shiftX,this.y+shiftY)}}class InfluentialEntity extends ImagedEntity{constructor(){super(),this.material=null,this.collider=null}setMaterial(material){this.material=material}setCollider(collider){this.collider=collider,collider.setEntity(this),collider.init()}}class MutableEntity extends InfluentialEntity{constructor(){super(),this.body=null,this.directionX=0,this.directionY=0}setRigidBody(body){this.body=body,null!==this.body&&(body.setEntity(this),body.init())}setDirection(directionX=this.directionX,directionY=this.directionY){this.directionX=directionX,this.directionY=directionY,BaseUtil.implementsOf(this.image,IDirectionalImage)&&this.image.setDirection(directionX,directionY)}deltaMove(dx,dy){this.setPosition(this.x+dx,this.y+dy),null!==this.collider&&this.collider.update()}}class EntityBuilder{constructor(){this.imageBuilder=null}setImageBuilder(image){this.imageBuilder=image}build(deploy,json){}}class EntityFactory{createEntity(id,deploy){}}class ImageBuilder{build(root,image){}}class StageParser{parse(filePath,width,height){}}class RigidBody{constructor(){this.diffX=0,this.diffY=0,this.isFixX=!1,this.isFixY=!1,this.enable=!0,this.entity=null,this.material=null}setEntity(entity){this.entity=entity}getEntity(){return this.entity}setMaterial(material){this.material=material}get velocityX(){return this.material.velocityX}get velocityY(){return this.material.velocityY}get accelerationX(){return this.material.accelerationX}get accelerationY(){return this.material.accelerationY}reset(){this.material.reset(),this.diffX=0,this.diffY=0,this.isFixX=!1,this.isFixY=!1}setNextAddVelocity(vx,vy){}enforce(forceX,forceY){}init(){}prepare(dt){}updateInfo(dt){}updateVelocity(dt){}updateEntity(dt){}update(dt){this.updateInfo(dt),this.enable&&(this.updateVelocity(dt),this.updateEntity(dt))}cleanup(dt){}}class RigidMaterial{constructor(){this.velocityX=0,this.velocityY=0,this.accelerationX=0,this.accelerationY=0}reset(){this.velocityX=0,this.velocityY=0,this.accelerationX=0,this.accelerationY=0}get k(){}get frictionX(){}get frictionY(){}get gravityScale(){}set k(val){}set frictionX(val){}set frictionY(val){}set gravityScale(val){}}class AABB{get startX(){}get startY(){}get endX(){}get endY(){}update(startX,startY,endX,endY,entity){}}class Collider{constructor(){this.aabb=null,this.collisions=[],this.response=!0,this.enable=!0,this.entity=null,this.cleared=!1}init(){this.cleared||this.clear(),this.update(),this.cleared=!1}clear(){this.collisions.length=0,this.cleared=!0}setEntity(entity){this.entity=entity}setAABB(aabb){this.aabb=aabb}getAABB(){return this.aabb}addCollision(collision){this.collisions.push(collision)}isResponse(collider){return this.response}isInCollider(x,y){}isCollision(collider,data=null){}isCollisionRoughly(collider){if(!this.enable)return!1;const me=this.getAABB(),you=collider.getAABB();return me.endX>=you.startX&&you.endX>=me.startX&&me.endY>=you.startY&&you.endY>=me.startY}fixBound(startX,startY,endX,endY){}update(){}render(ctx,shiftX=0,shiftY=0){}}class CollisionData{constructor(colliding,collided,nx,ny,px,py,depth){this.colliding=colliding,this.collided=collided,this.nx=nx,this.ny=ny,this.depth=depth,this.px=px,this.py=py,this.priorityVal=0}get priority(){return null===this.priorityVal&&(this.priorityVal=this.calcPriority()),this.priorityVal}register(colliding,collided,nx,ny,px,py,depth){this.colliding=colliding,this.collided=collided,this.nx=nx,this.ny=ny,this.px=px,this.py=py,this.depth=depth}init(){this.priorityVal=null}calcPriority(){}}class CollisionResponse{collisionResponse(data,dt){}}class Material{get mass(){}get e(){}get mu(){}}class PhysicalWorld{constructor(gravity){this.gravity=100*gravity,this.response=null}setResponse(response){this.response=response}getResponse(){return this.response}addEntity(entity){}removeEntity(entity){}getCollisionData(collider){}getCollisionSize(){}updateExternalForce(dt){}prepareBody(dt){}updateBody(dt){}updateBodyCleanup(dt){}initCollision(dt){}updateCollision(dt){}updateResponse(dt){}cleanup(dt){}update(dt){this.updateExternalForce(dt),this.prepareBody(dt),this.updateBody(dt),this.updateBodyCleanup(dt),this.initCollision(dt),this.updateCollision(dt),this.updateResponse(dt),this.cleanup(dt)}render(ctx,shiftX,shiftY){}}class Stage{constructor(stageWidth,stageHeight){this.stageWidth=stageWidth,this.stageHeight=stageHeight,this.enable=!0,this.back=null,this.camera=null,this.physic=null,this.factory=null}setBackground(back){this.back=back,this.back.init()}setCamera(camera){this.camera=camera}setPhysicalWorld(physic){this.physic=physic}setFactory(factory){this.factory=factory}getPhysicalWorld(){return this.physic}getCamera(){return this.camera}getFactory(){return this.factory}setEnable(enable){this.enable=enable}getEnable(){return this.enable}getStageWidth(){return this.stageWidth}getStageHeight(){return this.stageHeight}addEntityByID(id,deploy){const ret=this.getFactory().createEntity(id,deploy);return this.addEntity(ret),ret}addEntity(entity){null===entity.stage&&entity.setStage(this),entity.init()}removeEntity(entity){}removeEntityImmediately(entity){}getEntities(){}updateEntity(dt){}updatePhysics(dt){}updateBackground(dt){}updateCamera(dt){}init(){}update(dt){this.getEnable()&&(this.updateEntity(dt),this.updatePhysics(dt)),this.updateBackground(dt),this.updateCamera(dt)}renderBackground(ctx,shiftX,shiftY){}renderEntity(ctx,shiftX,shiftY){}renderWorld(ctx,shiftX,shiftY){}render(ctx,shiftX=0,shiftY=0){shiftX+=this.camera.baseX,shiftY+=this.camera.baseY,this.renderBackground(ctx,shiftX,shiftY),this.renderEntity(ctx,shiftX,shiftY),this.renderWorld(ctx,shiftX,shiftY)}}class StageManager{constructor(){StageManager.it=this,this.parser=null,this.width=0,this.height=0}setStageParser(parser){this.parser=parser}setStageSize(width,height){this.width=width,this.height=height}pushStage(stageName){}replaceStage(stageName){this.popStage(),this.pushStage(stageName)}popStage(){}getStage(){}update(dt){const stage=this.getStage();null!==stage&&stage.update(dt)}render(ctx,shiftX=0,shiftY=0){const stage=this.getStage();null!==stage&&stage.render(ctx,shiftX,shiftY)}}StageManager.it=null;class Timer{constructor(){this.deltaTime=0,Timer.it=this}startTimer(name){}stopTimer(name){}getTimer(name){}init(){}update(dt){this.deltaTime=dt}render(ctx,x,y){}}Timer.it=null;class BaseUtil{static implementsOf(instance,i){let inter=BaseUtil.interfaces[i.name];return void 0===inter&&(inter=BaseUtil.interfaces[i.name]=new(i.bind(i))),inter.validate(instance)}static getClassName(instance){return instance.constructor.toString().split("\n")[0].split(" ")[1]}}BaseUtil.interfaces={};class Interface{constructor(){this._methods=[],this._getters=[],this._setters=[],this.addMethodsAutomatically()}addMethodsAutomatically(){let proto=this.__proto__;for(;null!==proto;){for(const it of Object.getOwnPropertyNames(proto)){if("constructor"===it){if(proto[it]===Interface)return;continue}proto[it]instanceof Function&&this.addMethod(proto[it]);const disc=Object.getOwnPropertyDescriptor(proto,it);void 0!==disc&&(void 0!==disc.get&&this._getters.push(it),void 0!==disc.set&&this._setters.push(it))}proto=proto.__proto__}}addMethod(method){this._methods.push(new Method(method.name,method.length))}validate(instance){if(null==instance)return!1;for(const it of this._methods)if(!(instance[it.name]instanceof Function&&instance[it.name].length===it.length))return!1;for(const it of this._getters){let proto=instance.__proto__,exists=!1;for(;null!==proto;){const disc=Object.getOwnPropertyDescriptor(proto,it);if(void 0!==disc&&void 0!==disc.get){exists=!0;break}proto=proto.__proto__}if(!exists)return!1}for(const it of this._setters){let proto=instance.__proto__,exists=!1;for(;null!==proto;){const disc=Object.getOwnPropertyDescriptor(proto,it);if(void 0!==disc&&void 0!==disc.set){exists=!0;break}proto=proto.__proto__}if(!exists)return!1}return!0}}class Method{constructor(name,length){this.name=name,this.length=length}}class GameDebugger{constructor(){GameDebugger.it=this}register(name,value){}init(){}update(dt){}render(ctx,x,y){}}GameDebugger.it=null,GameDebugger.debug=!1;class DebugLayer extends Layer{constructor(debug){super(),this.debug=debug}init(){this.debug.init()}update(dt){this.debug.update(dt)}render(ctx){Timer.it.render(ctx,this.x,this.y),this.debug.render(ctx,this.x+this.width,this.y)}}class DebugStage extends Stage{constructor(stage){super(stage.stageWidth,stage.stageHeight),this.stage=stage,this.debugMode=!1}registerInformation(dt){const players=this.getEntities().filter(it=>BaseUtil.implementsOf(it,IPlayable));if(players.length>0){const player=players[0];GameDebugger.it.register("time",`${dt} mssc`),GameDebugger.it.register("collision",`${this.getPhysicalWorld().getCollisionSize()} collision`),player instanceof InfluentialEntity&&GameDebugger.it.register("pcollision",`${player.collider.collisions.length} player collision`),GameDebugger.it.register("physics",`${BaseUtil.getClassName(this.getPhysicalWorld()instanceof DebugWorld?this.getPhysicalWorld().world:this.getPhysicalWorld())}-${BaseUtil.getClassName(this.getPhysicalWorld().getResponse())}`),GameDebugger.it.register("ppos",`Pos(${Math.floor(player.x)}, ${Math.floor(player.y)})`),player instanceof MutableEntity&&(GameDebugger.it.register("pvec",`Vec(${Math.floor(player.body.velocityX)}, ${Math.floor(player.body.velocityY)})`),GameDebugger.it.register("pacc",`Acc(${Math.floor(player.body.accelerationX)},${Math.floor(player.body.accelerationY)})`)),player instanceof StateCharacter&&null!==player.state&&GameDebugger.it.register("state",`${BaseUtil.getClassName(player.state)}`),GameDebugger.it.register("mouse",`M(${Math.floor(Input.mouse.getMouseX())},${Math.floor(Input.mouse.getMouseY())})`)}}renderEntityInformation(ctx,shiftX,shiftY){const startX=-this.stage.camera.cameraX,startY=-this.stage.camera.cameraY,endX=startX+this.stage.camera.screenWidth,endY=startY+this.stage.camera.screenHeight,mx=Input.mouse.getMouseX()+startX,my=Input.mouse.getMouseY()+startY;for(const it of this.getEntities())it.x+it.width>=startX&&it.x<endX&&it.y+it.height>=startY&&it.y<endY&&(it instanceof InfluentialEntity&&null!==it.collider?(it.collider.render(ctx,this.stage.camera.baseX-startX,this.stage.camera.baseY-startY),it.collider.isInCollider(mx,my)&&(ctx.fillText(`P(${Math.floor(it.x)}, ${Math.floor(it.y)})`,mx-startX,my-startY,0,0,20,"white"),it instanceof MutableEntity&&null!==it.body&&(ctx.fillText(`V(${Math.floor(it.body.velocityX)}, ${Math.floor(it.body.velocityY)})`,mx-startX,my-startY+30,0,0,20,"white"),ctx.fillText(`M(${Math.floor(it.body.vpx)}, ${Math.floor(it.body.vpy)}),(${Math.floor(it.body.vmx)}, ${Math.floor(it.body.vmy)})`,mx-startX,my-startY+60,0,0,20,"white"),ctx.fillText(`A(${Math.floor(it.body.accelerationX)}, ${Math.floor(it.body.accelerationY)})`,mx-startX,my-startY+90,0,0,20,"white"),ctx.fillText(`F((${it.body.isFixX}, ${it.body.isFixY}) - (${Math.floor(it.body.diffX)}, ${Math.floor(it.body.diffY)}))`,mx-startX,my-startY+120,0,0,20,"white")))):BaseUtil.implementsOf(it,IColliderable)&&(it.getCollider().render(ctx,this.stage.camera.baseX-startX,this.stage.camera.baseY-startY),it.getCollider().isInCollider(mx,my)&&ctx.fillText(`P(${Math.floor(it.x)}, ${Math.floor(it.y)})`,mx-startX,my-startY,0,0,20,"white")))}setBackground(back){this.stage.setBackground(back)}setCamera(camera){this.stage.setCamera(camera)}setPhysicalWorld(physic){this.stage.setPhysicalWorld(physic)}setFactory(factory){this.stage.setFactory(factory)}getCamera(){return this.stage.getCamera()}getPhysicalWorld(){return this.stage.getPhysicalWorld()}getFactory(){return this.stage.getFactory()}setEnable(enable){super.setEnable(enable),this.stage.setEnable(enable)}getEnable(){return this.stage.getEnable()}getStageWidth(){return this.stage.getStageWidth()}getStageHeight(){return this.stage.getStageHeight()}addEntity(entity){entity.setStage(this),this.stage.addEntity(entity)}removeEntity(entity){this.stage.removeEntity(entity)}removeEntityImmediately(entity){this.stage.removeEntityImmediately(entity)}getEntities(){return this.stage.getEntities()}init(){this.stage.init()}updateEntity(dt){Timer.it.startTimer("entity"),this.stage.updateEntity(dt),Timer.it.stopTimer("entity")}updatePhysics(dt){Timer.it.startTimer("physics"),this.stage.updatePhysics(dt),Timer.it.stopTimer("physics")}updateBackground(dt){this.stage.updateBackground(dt)}updateCamera(dt){this.stage.updateCamera(dt)}update(dt){Input.key.isPress(Input.key.a()+5)&&(this.debugMode=!this.debugMode),(!this.debugMode||Input.key.isPress(Input.key.a())||Input.key.isPressed(Input.key.a()+1))&&super.update(Input.key.isPressed(Input.key.a()+8)?10*dt:dt),this.registerInformation(dt)}renderBackground(ctx,shiftX,shiftY){Timer.it.startTimer("renderBackground"),this.stage.renderBackground(ctx,shiftX,shiftY),Timer.it.stopTimer("renderBackground")}renderEntity(ctx,shiftX,shiftY){Timer.it.startTimer("renderEntity"),this.stage.renderEntity(ctx,shiftX,shiftY),Timer.it.stopTimer("renderEntity"),GameDebugger.debug&&this.renderEntityInformation(ctx,shiftX,shiftY)}renderWorld(ctx,shiftX,shiftY){this.stage.renderWorld(ctx,shiftX,shiftY)}render(ctx,shiftX=0,shiftY=0){shiftX+=this.stage.camera.baseX,shiftY+=this.stage.camera.baseY,this.renderBackground(ctx,shiftX,shiftY),this.renderEntity(ctx,shiftX,shiftY)}}class DebugWorld extends PhysicalWorld{constructor(world,stageWidth,stageHeight){super(world.gravity),this.world=world,this.stageWidth=stageWidth,this.stageHeight=stageHeight}setResponse(response){this.world.setResponse(response)}getResponse(){return this.world.getResponse()}addEntity(entity){this.world.addEntity(entity)}removeEntity(entity){this.world.removeEntity(entity)}getCollisionData(collider){return this.world.getCollisionData(collider)}getCollisionSize(){return this.world.getCollisionSize()}updateExternalForce(dt){Timer.it.startTimer("external"),this.world.updateExternalForce(dt),Timer.it.stopTimer("external")}prepareBody(dt){Timer.it.startTimer("body"),this.world.prepareBody(dt)}updateBody(dt){this.world.updateBody(dt)}updateBodyCleanup(dt){this.world.updateBodyCleanup(dt),Timer.it.stopTimer("body")}initCollision(dt){Timer.it.startTimer("collide"),this.world.initCollision(dt)}updateCollision(dt){this.world.updateCollision(dt),Timer.it.stopTimer("collide")}updateResponse(dt){Timer.it.startTimer("response"),this.world.updateResponse(dt),Timer.it.stopTimer("response")}cleanup(dt){this.world.cleanup()}update(dt){if(super.update(dt),Input.key.isPress(Input.key.a()+16)){const response=this.world.getResponse();response instanceof UnderRepulsionResponse?this.world.setResponse(new RepulsionResponse):this.world.setResponse(new UnderRepulsionResponse)}if(Input.key.isPress(Input.key.a()+22)){const world=this.world instanceof SplitWorld?new SequentialWorld(this.gravity/1e4):new SplitWorld(this.stageWidth,this.stageHeight,this.gravity/1e4);world.setResponse(this.world.getResponse());for(const it of this.world.entities)world.addEntity(it);this.world=world}}}class VolatileDebugger extends GameDebugger{constructor(){super(),this.registeredData={},this.renderingData=[]}register(name,value){this.registeredData[name]=value}update(dt){this.renderingData.length=0;for(const it in this.registeredData)this.registeredData.hasOwnProperty(it)&&this.renderingData.push(this.registeredData[it]);this.registeredData={}}render(ctx,x,y){for(const it of this.renderingData)ctx.fillText(`${it}`,x,y,1,0,20,"white"),y+=30}}class AutoInputEvent extends GameEvent{constructor(){super(),this.orders=[],this.nextOrderNumber=0}addOrder(order){this.orders.push(order)}init(){Input.key.setInputEnable(!1),this.nextOrderNumber=0,this.orders.length>0&&this.orders[this.nextOrderNumber].init()}destruct(){Input.key.setInputEnable(!0)}update(dt){if(this.orders.length<=this.nextOrderNumber)return this.op.next(),!0;const order=this.orders[this.nextOrderNumber];return!!order.udpate(dt)&&(order.destruct(),this.orders.length>++this.nextOrderNumber?(this.orders[this.nextOrderNumber].init(),!1):(this.op.next(),!0))}}class DelayEvent extends GameEvent{constructor(delay){super(),this.delay=delay,this.count=0}init(){this.count=0}update(dt){return this.count+=dt/1e3,this.count>this.delay&&(this.op.next(),!0)}}class DeleteEvent extends GameEvent{constructor(name){super(),this.name=name}init(){const removes=[];for(const it of this.op.getRunningEvents())it instanceof NamedEvent&&it.getName()===this.name&&removes.push(it);for(const it of removes)this.op.delete(it);this.op.next()}}class ImageEvent extends NamedEvent{constructor(name,x,y,image){super(name),this.x=x,this.y=y,this.image=image}init(){this.op.next(),this.image.init()}update(dt){return this.image.update(),!1}render(ctx){super.render(ctx),this.image.render(ctx,this.x,this.y)}}class InputOrder{init(){}destruct(){}udpate(dt){}}class LoopInputOrder extends InputOrder{constructor(loopNumber){super(),this.loopNumber=loopNumber,this.orders=[],this.orderIndex=0}addOrder(order){this.orders.push(order)}init(){this.orderIndex=0,this.orders.length>0&&this.orders[this.orderIndex].init()}udpate(dt){if(0===this.orders.length)return!0;const order=this.orders[this.orderIndex];return!!order.udpate(dt)&&(order.destruct(),this.orderIndex+=1,this.orderIndex<this.orders.length?(this.orders[this.orderIndex].init(),!1):(this.orderIndex=0,this.orders[this.orderIndex].init(),this.loopNumber-=1,this.loopNumber<=0))}}class WaitInputOrder extends InputOrder{constructor(time){super(),this.time=time,this.remainingTime=time}init(){this.remainingTime=this.time}udpate(dt){return(this.remainingTime-=dt/1e3)<=0}}class SequentialEvent extends GameEvent{constructor(){super(),this.events=[],this.nextEventNumber=0,this.runningEvents=[]}addEvent(event){this.events.push(event)}next(){if(this.nextEventNumber<this.events.length){const event=this.events[this.nextEventNumber++];this.runningEvents.push(event),event.init()}else this.op.next()}delete(event){const index=this.runningEvents.indexOf(event);index>=0&&(this.runningEvents.splice(index,1),event.destruct())}getRunningEvents(){return this.runningEvents}init(){super.init(),this.nextEventNumber=0;for(const it of this.events)it.setEventOperator(this);this.next()}destruct(){for(const it of this.runningEvents)it.destruct()}update(dt){const removes=[];for(const it of this.runningEvents)it.update(dt)&&removes.push(it);for(const it of removes){const index=this.runningEvents.indexOf(it);index>=0&&(it.destruct(),this.runningEvents.splice(index,1))}return 0===this.runningEvents.length&&this.nextEventNumber>=this.events.length}render(ctx){for(const it of this.runningEvents)it.render(ctx)}}class CameraEvent extends NamedEvent{constructor(name,x,y){super(name),this.toX=x,this.toY=y,this.camera=null,this.stage=null}setStage(stage){this.stage=stage}init(){this.camera=new EventCamera(this.stage.getCamera()),this.camera.setToPosition(this.toX,this.toY),this.camera.setScreenSize(this.stage.getCamera().screenWidth,this.stage.getCamera().screenHeight),this.stage.setCamera(this.camera),this.op.next()}destruct(){this.stage.setCamera(this.camera.getBaseCamera())}update(dt){return!1}}class ControlEntityEvent extends StageEvent{constructor(name){super(),this.targetName=name,this.vx=0,this.vy=0,this.fx=0,this.fy=0}setVelocity(vx,vy){this.vx=vx,this.vy=vy}setForce(fx,fy){this.fx=fx,this.fy=fy}init(){super.init();let target=null;"player"===this.targetName&&(target=this.stage.getEntities().find(it=>BaseUtil.implementsOf(it,IPlayable))),null!==target&&target instanceof MutableEntity&&(target.body.setNextAddVelocity(this.vx-target.body.velocityX,this.vy-target.body.velocityY),target.body.enforce(this.fx,this.fy)),this.op.next()}}class SequentialStageEvent extends SequentialEvent{constructor(){super(),this.stage=null}setStage(stage){this.stage=stage}init(){for(const it of this.events)BaseUtil.implementsOf(it,IStageEvent)&&it.setStage(this.stage);super.init()}}class StageStopEvent extends NamedEvent{constructor(name){super(name),this.stage=null}setStage(stage){this.stage=stage}init(){this.stage.setEnable(!1),this.op.next()}destruct(){this.stage.setEnable(!0)}update(dt){return!1}}class TalkEvent extends StageEvent{constructor(sentence){super(),this.sentence=sentence,this.talkCount=0,this.talked=!1}init(){this.talkCount=0,this.talked=!1,this.stage.setEnable(!1)}destruct(){this.stage.setEnable(!0)}update(dt){if(this.talked||(this.talkCount+=dt/100,this.talkCount>this.sentence.length&&(this.talkCount=this.sentence.length,this.talked=!0)),Input.key.isPress(Input.key.yes())){if(this.talked)return this.op.next(),!0;this.talkCount=this.sentence.length,this.talked=!0}return!1}render(ctx){const id=ResourceManager.image.load("window/win2.png"),face=ResourceManager.image.load("face/actor.png");Util.renderWindow(ctx,id,0,0,600,200),Util.renderWindow(ctx,id,610,10,180,180),ctx.drawImage(face,636,36,128,128);const texts=[];texts.push("");for(const word of this.sentence.substr(0,this.talkCount))ctx.measureText(texts[texts.length-1]+word,25)<=536?texts[texts.length-1]+=word:texts.push(word);for(let i=0;i<texts.length;++i)ctx.fillText(texts[i],32,32+35*i,0,0,25)}}class TransitionalEvent extends StageEvent{constructor(stageName,isReplace){super(),this.stageName=stageName,this.isReplace=isReplace}init(){this.isReplace?StageManager.it.replaceStage(this.stageName):StageManager.it.pushStage(this.stageName),this.op.next()}}class WaitKeyEvent extends StageEvent{init(){this.stage.setEnable(!1)}destruct(){this.stage.setEnable(!0)}update(dt){return!!Input.key.isPress(Input.key.yes())&&(this.op.next(),!0)}}class SimpleEventBuilder extends EventBuilder{makeImage(image){return this.imageBuilder.build("event",image)}makeInputOrder(order){switch(order.type){case"up":return new DirectionInputOrder(order.time,0,-1);case"down":return new DirectionInputOrder(order.time,0,1);case"right":return new DirectionInputOrder(order.time,1,0);case"left":return new DirectionInputOrder(order.time,-1,0);case"wait":return new WaitInputOrder(order.time);case"loop":{const ret=new LoopInputOrder(order.number);for(const it of order.orders)ret.addOrder(this.makeInputOrder(it));return ret}}}makeEvent(event){switch(event.type){case"talk":return new TalkEvent(event.sentence);case"waitkey":return new WaitKeyEvent;case"image":return new ImageEvent(event.name,event.x,event.y,this.makeImage(event.image));case"delete":return new DeleteEvent(event.name);case"delay":return new DelayEvent(event.delay);case"stop":return new StageStopEvent(event.name);case"transition":return new TransitionalEvent(event.stage,event.replace);case"auto":{const ret=new AutoInputEvent;for(const it of event.orders)ret.addOrder(this.makeInputOrder(it));return ret}case"control":{const ret=new ControlEntityEvent(event.target);return void 0!==event.vx&&void 0!==event.vy&&ret.setVelocity(event.vx,event.vy),void 0!==event.fx&&void 0!==event.fy&&ret.setForce(event.fx,event.fy),ret}case"camera":return new CameraEvent(event.name,event.x,event.y);case"sequential":{let ret=new SequentialEvent;for(const it of event.events)if(BaseUtil.implementsOf(this.makeEvent(it),IStageEvent)){ret=new SequentialStageEvent;break}for(const it of event.events)ret.addEvent(this.makeEvent(it));return ret}}}build(json){return this.makeEvent(json)}}class QueueEventManager extends EventManager{constructor(){super(),this.events=[],this.runningEvents=[]}register(event){event.setEventOperator(this),this.events.push(event),1===this.events.length&&this.next()}unregister(event){let index=this.events.indexOf(event);index>=0&&this.events.splice(index,1),(index=this.runningEvents.indexOf(event))>=0&&(this.runningEvents.splice(index,1),event.destruct())}clear(){for(const it of this.runningEvents)it.destruct();this.events.length=0,this.runningEvents.length=0}next(){const event=this.events[0];void 0!==event&&(this.events.splice(0,1),this.runningEvents.push(event),event.init())}delete(event){this.unregister(event)}getRunningEvents(){return this.runningEvents}removeEvents(removes){for(const it of removes)this.unregister(it)}}class AllInput extends Input{constructor(key,mouse){super(),this.keyDelegate=key,this.mouseDelegate=mouse,this.mousBaseCode=1e3}setScreen(screen){super.setScreen(screen),this.keyDelegate instanceof Input&&this.keyDelegate.setScreen(screen),this.mouseDelegate instanceof Input&&this.mouseDelegate.setScreen(screen)}init(){this.keyDelegate instanceof Input&&this.keyDelegate.init(),this.mouseDelegate instanceof Input&&this.mouseDelegate.init()}update(){this.keyDelegate instanceof Input&&this.keyDelegate.update(),this.mouseDelegate instanceof Input&&this.mouseDelegate.update()}a(){return this.keyDelegate.a()}zero(){return this.keyDelegate.zero()}space(){return this.keyDelegate.space()}right(){return this.keyDelegate.right()}left(){return this.keyDelegate.left()}up(){return this.keyDelegate.up()}down(){return this.keyDelegate.down()}yes(){return this.keyDelegate.yes()}no(){return this.keyDelegate.no()}sub(){return this.keyDelegate.sub()}mRight(){return this.mouseDelegate.mRight()+this.mousBaseCode}mLeft(){return this.mouseDelegate.mLeft()+this.mousBaseCode}mCenter(){return this.mouseDelegate.mCenter()+this.mousBaseCode}getMouseX(){return this.mouseDelegate.getMouseX()}getMouseY(){return this.mouseDelegate.getMouseY()}clear(){this.keyDelegate.clear(),this.mouseDelegate.clear()}setInputEnable(enable){this.mouseDelegate.setInputEnable(enable),this.keyDelegate.setInputEnable(enable)}blockInput(code){code>=this.mousBaseCode?this.mouseDelegate.blockInput(code-this.mousBaseCode):this.keyDelegate.blockInput(code)}unblockInput(code){code>=this.mousBaseCode?this.mouseDelegate.unblockInput(code-this.mousBaseCode):this.keyDelegate.unblockInput(code)}press(code){code>=this.mousBaseCode?this.mouseDelegate.press(code-this.mousBaseCode):this.keyDelegate.press(code)}unpress(code){code>=this.mousBaseCode?this.mouseDelegate.unpress(code-this.mousBaseCode):this.keyDelegate.unpress(code)}isPress(code){return code>=this.mousBaseCode?this.mouseDelegate.isPress(code-this.mousBaseCode):this.keyDelegate.isPress(code)}isPressed(code){return code>=this.mousBaseCode?this.mouseDelegate.isPressed(code-this.mousBaseCode):this.keyDelegate.isPressed(code)}}class StateInputManager extends Input{constructor(){super(),this.inputState=[],this.blocked=[],this.STATE={NONE:0,PRESS:1,PRESSED:2,ON:3},this.target=null,this.enable=!0}init(){this.target=this.screen.getTarget(),this.enable=!0}update(){for(let i=0;i<this.inputState.length;++i)this.inputState[i]===this.STATE.PRESS?this.inputState[i]=this.STATE.PRESSED:this.inputState[i]===this.STATE.PRESSED&&(this.inputState[i]=this.STATE.ON),this.blocked[i]=!1}clear(){for(let i=0;i<this.inputState.length;++i)this.inputState[i]=this.STATE.NONE}setInputEnable(enable){this.enable=enable,this.clear()}blockInput(code){this.blocked[code]=!0}unblockInput(code){this.blocked[code]=!1}press(code){this.inputState[code]=this.STATE.PRESSED}unpress(code){this.inputState[code]=this.STATE.NONE}isPress(code){return!this.blocked[code]&&void 0!==this.inputState[code]&&this.inputState[code]===this.STATE.PRESSED}isPressed(code){return!this.blocked[code]&&void 0!==this.inputState[code]&&(this.inputState[code]===this.STATE.PRESSED||this.inputState[code]===this.STATE.ON)}}class CachedArrayManager extends ResourceManager{constructor(root){super(root),this.resources=[],this.caches={}}loadResource(filePath){}load(filePath){filePath.startsWith(this.root)||(filePath=this.root+filePath);const cache=this.caches[filePath];return void 0!==cache?cache:(this.resources.push(this.loadResource(filePath)),this.caches[filePath]=this.resources.length-1)}unload(id){delete this.caches[this.getPath(id)],this.resources.splice(index,1,null)}reload(){for(const it in this.caches)this.caches.hasOwnProperty(it)&&(this.resources[this.caches[it]]=this.loadResource(`${it}?time=${new Date}`))}getPath(id){for(const path in this.caches)if(this.caches.hasOwnProperty(path)&&this.caches[path]===id)return path.replace(this.root,"");return null}}class CachedImage extends CachedArrayManager{loadResource(filePath){const image=new Image;return image.src=filePath,image}getWidth(id){const image=this.resources[id];return void 0===image?-1:image.width}getHeight(id){const image=this.resources[id];return void 0===image?-1:image.height}getImage(id){const ret=this.resources[id];return void 0===ret?null:ret}}class CachedMusic extends CachedArrayManager{constructor(root){super(root),window.AudioContext=window.AudioContext||window.webkitAudioContext,this.context=new AudioContext}loadResource(filePath){const id=this.resources.length,instance=this,request=new XMLHttpRequest;return request.open("GET",filePath,!0),request.responseType="arraybuffer",request.onload=function(){200!==request.status&&0!==request.status||instance.context.decodeAudioData(request.response,function(buffer){const source=instance.context.createBufferSource();source.buffer=buffer,source.connect(instance.context.destination),source.loop=!0,instance.resources[id]=source})},request.send(),null}getMusic(id){const music=this.resources[id];return void 0===music?null:music}}class DelegateImage extends GameImage{constructor(baseImage){super(),this.baseImage=baseImage}setDirection(directionX,directionY){BaseUtil.implementsOf(this.baseImage,IDirectionalImage)&&this.baseImage.setDirection(directionX,directionY)}setClipArea(clipX,clipY,clipWidth,clipHeight){BaseUtil.implementsOf(this.baseImage,IClipImage)&&this.baseImage.setClipArea(clipX,clipY,clipWidth,clipHeight)}setSize(width,height){this.baseImage.setSize(width,height)}setImageID(imageID){this.baseImage.setImageID(imageID)}getImageID(){return this.baseImage.getImageID()}getWidth(){return this.baseImage.getWidth()}getHeight(){return this.baseImage.getHeight()}getSourceOffsetX(){return this.baseImage.getSourceOffsetX()}getSourceOffsetY(){return this.baseImage.getSourceOffsetY()}getSourceWidth(){return this.baseImage.getSourceWidth()}getSourceHeight(){return this.baseImage.getSourceHeight()}init(){this.baseImage.init()}update(dt){this.baseImage.update(dt)}render(ctx,x,y){this.baseImage.render(ctx,x,y)}}class DirectionalImage extends DelegateImage{constructor(baseImage){super(baseImage),this.directionX=0,this.directionY=0}setDirection(directionX,directionY){this.directionX=directionX,this.directionY=directionY}render(ctx,x,y){this.setSize(this.getWidth()*(0===this.directionX?1:this.directionX),this.getHeight()*(0===this.directionY?1:-1*this.directionY)),super.render(ctx,x,y),this.setSize(this.getWidth()*(0===this.directionX?1:this.directionX),this.getHeight()*(0===this.directionY?1:-1*this.directionY))}}class GLContext extends Context{setScreen(screen){super.setScreen(screen),this.gl_=this.screen.getCanvas().getContext("webgl")}preRendering(){}postRendering(){}fillText(text,x,y,anchorX,anchorY,size,color,font){}strokeLine(sx,sy,ex,ey,color,lineWidth){}strokeCircle(x,y,radius,startAngle,endAngle,anticlockwise,color,lineWidth){}strokeRect(x,y,width,height,color,lineWidth){}drawImage(imageID,x,y,width,height,srcX,srcY,srcW,srcH){}}class JSContext extends Context{constructor(){super(),this._fontColor="black",this._fontSize=50,this._fontName="Arial",this._lineColor="red",this._lineWidth=1,this.ctx=null}init(){this.ctx=this.screen.getCanvas().getContext("2d")}preRendering(){this.ctx.mozImageSmoothingEnabled=!1,this.ctx.webkitImageSmoothingEnabled=!1,this.ctx.msImageSmoothingEnabled=!1,this.ctx.imageSmoothingEnabled=!1,this.ctx.save(),this.ctx.scale(this.screen.gameSize,this.screen.gameSize),this.ctx.fillStyle="black",this.ctx.fillRect(0,0,this.screen.width,this.screen.height)}postRendering(){this.ctx.restore()}fillText(text,x,y,anchorX=0,anchorY=0,size=this._fontSize,color=this._fontColor,font=this._fontName){this.ctx.font=size+"px "+font,this.ctx.fillStyle=color,this.ctx.fillText(text,x-anchorX*this.ctx.measureText(text).width,y+(1-anchorY)*size)}measureText(text,size=this._fontSize,font=this._fontName){return this.ctx.font=size+"px "+font,this.ctx.measureText(text).width}strokeLine(sx,sy,ex,ey,color=this._lineColor,lineWidth=this._lineWidth){this.ctx.strokeStyle=color,this.ctx.lineWidth=lineWidth,this.ctx.beginPath(),this.ctx.moveTo(sx,sy),this.ctx.lineTo(ex,ey),this.ctx.stroke(),this.ctx.closePath()}strokeCircle(x,y,radius,startAngle,endAngle,anticlockwise,color=this._lineColor,lineWidth=this._lineWidth){this.ctx.strokeStyle=color,this.ctx.lineWidth=lineWidth,this.ctx.beginPath(),this.ctx.arc(x,y,radius,startAngle,endAngle,anticlockwise),this.ctx.stroke(),this.ctx.closePath()}strokeRect(x,y,width,height,color=this._lineColor,lineWidth=this._lineWidth){this.ctx.strokeStyle=color,this.ctx.lineWidth=lineWidth,this.ctx.strokeRect(x,y,width,height)}fillRect(x,y,width,height,color=this._lineColor,lineWidth=this._lineWidth){this.ctx.fillStyle=color,this.ctx.lineWidth=lineWidth,this.ctx.fillRect(x,y,width,height)}drawImage(imageID,x,y,width,height,srcX,srcY,srcW,srcH){const image=this.image.getImage(imageID);x=Math.round(x),y=Math.round(y),void 0!==width?(width=Math.round(width),height=Math.round(height),this.ctx.save(),width<0&&(x=-x-(width=-width),this.ctx.scale(-1,1)),height<0&&(y=-y-(height=-height),this.ctx.scale(1,-1)),void 0===srcX?this.ctx.drawImage(image,x,y,width,height):(srcX=Math.round(srcX),srcY=Math.round(srcY),srcW=Math.round(srcW),srcH=Math.round(srcH),this.ctx.drawImage(image,srcX,srcY,srcW,srcH,x,y,width,height)),this.ctx.restore()):this.ctx.drawImage(image,x,y)}}class SingleImage extends GameImage{constructor(imageID,width=null,height=null){super(),this.imageID=imageID,this.width=width,this.height=height}setSize(width,height){this.width=width,this.height=height}setImageID(imageID){this.imageID=imageID}getImageID(){return this.imageID}getWidth(){return this.width}getHeight(){return this.height}getSourceOffsetX(){return 0}getSourceOffsetY(){return 0}getSourceWidth(){return ResourceManager.image.getWidth(this.imageID)}getSourceHeight(){return ResourceManager.image.getHeight(this.imageID)}update(dt){if(null===this.width){const width=this.getSourceWidth();width>0&&(this.width=width)}if(null===this.height){const height=this.getSourceHeight();height>0&&(this.height=height)}}render(ctx,x,y){ctx.drawImage(this.imageID,x,y,this.width,this.height)}}class TileImage extends SingleImage{constructor(imageID,width,height,srcX,srcY,srcW,srcH){super(imageID,width,height),this.srcX=srcX,this.srcY=srcY,this.srcW=srcW,this.srcH=srcH}getSourceOffsetX(){return this.srcX}getSourceOffsetY(){return this.srcY}getSourceWidth(){return this.srcW}getSourceHeight(){return this.srcH}render(ctx,x,y){ctx.drawImage(this.imageID,x,y,this.width,this.height,this.srcX,this.srcY,this.srcW,this.srcH)}}class BufferSourceMusic extends Music{constructor(){super(),this.bgm=null}_play(musicID,loop){const music=this.music.getMusic(musicID);if(null!==music)music.loop=loop,music.start(0);else{const instance=this,id=setInterval(()=>{const music=instance.music.getMusic(musicID);null!==music&&(this._play(musicID,loop),clearInterval(id),loop&&(this.bgm=music))},1e3/60)}return music}playSE(musicID){this._play(musicID,!1)}playBGM(musicID){null!==this.bgm&&this.stopBGM(),this.bgm=this._play(musicID,!0)}pauseBGM(){}resumeBGM(){}stopBGM(){null!==this.bgm&&this.bgm.stop()}}class DefaultTitleScene extends Scene{constructor(){super(),this.r_=10,this.angle_=0}update(dt){Input.mouse.isPressed(Input.mouse.mLeft())?(this.r_+=dt/20,this.angle_=this.angle_+Math.PI/10*dt/20):(this.r_-=dt/20,this.angle_=this.angle_+Math.PI/30*dt/20),this.r_=this.r_>20?20:this.r_<10?10:this.r_,this.angle_>2.5*Math.PI&&(this.angle_-=2.5*Math.PI)}render(ctx){ctx.fillText("Sample",400,300,.5),Input.key.isPressed(Input.key.space())&&ctx.fillText("Enter pressed",400,400,.5,0,30,"red");const angle=this.angle_>2*Math.PI?2*Math.PI:this.angle_;ctx.strokeCircle(Input.mouse.getMouseX(),Input.mouse.getMouseY(),this.r_,0,angle,!1)}}class FloatLayer extends Layer{constructor(delegate){super(),this.delegate=delegate}setPosition(x,y,z){super.setPosition(x,y,z),this.delegate.setPosition(x,y,z)}setSize(width,height){super.setSize(width,height),this.delegate.setSize(width,height)}init(){this.delegate.init()}update(dt){this.delegate.update(dt)}render(ctx){this.delegate.render(ctx)}}class GameoverLayer extends Layer{update(dt){}render(ctx){ctx.fillText("Gameover",this.x+this.width/2,this.y+this.height/2,.5,.5,100,"red")}}class ScrollLayer extends Layer{constructor(delegate){super(),this.delegate=delegate,this.scrollX=0,this.scrollY=0}scroll(x,y){this.scrollX+=x,this.scrollY+=y}init(){this.delegate.init()}update(dt){const width=this.delegate.width,height=this.delegate.height;this.width<width?this.scrollX<0?this.scrollX=0:this.scrollX>width-this.width&&(this.scrollX=width-this.width):this.scrollX=0,this.height<height?this.scrollY<0?this.scrollY=0:this.scrollY>height-this.height&&(this.scrollY=height-this.height):this.scrollY=0,this.delegate.setPosition(this.x-this.scrollX,this.y-this.scrollY,this.z),this.delegate.clip(this.x,this.y,this.width,this.height),this.delegate.update(dt)}render(ctx){this.delegate.render(ctx)}}class TabbedLayer extends Layer{setPosition(x,y,z){super.setPosition(x,y,z);for(const it of this.getTabs())it.setPosition(x,y,z)}setSize(width,height){super.setSize(width,height);for(const it of this.getTabs())it.setSize(width,height)}addTab(layer){layer.init()}removeTab(layer){}getTab(){}getTabs(){}update(dt){const tab=this.getTab();null!==tab&&tab.update(dt)}render(ctx){const tab=this.getTab();null!==tab&&tab.render(ctx)}}class StackSceneManager extends SceneManager{constructor(){super(),this.scenes=[]}getScene(){return this.scenes[this.scenes.length-1]}pushScene(scene){this.scenes.push(scene),super.pushScene(scene)}popScene(){this.scenes.pop()}}class CanvasScreen extends GameScreen{constructor(width=800,height=600){super(width,height),this.canvas=null}getTarget(){return this.canvas}getCanvas(){return this.canvas}}class DelegateScreen extends GameScreen{constructor(delegate){super(delegate.width,delegate.height),this.delegate=delegate}init(){this.delegate.init()}getTarget(){return this.delegate.getTarget()}getCanvas(){return this.delegate.getCanvas()}}class DetectiveScreen extends CanvasScreen{init(){this.canvas=document.querySelector("canvas");const style=document.createElement("style");style.append("canvas {display:block;width: "+this.width+"px;height: "+this.height+"px;margin: 0px auto;}"),document.head.appendChild(style),this.canvas.width=this.width,this.canvas.height=this.height,this.canvas.setAttribute("style","canvas")}}class FitableScreen extends DelegateScreen{init(){super.init(),(window.onresize=(()=>{const size=Math.min((innerWidth-16)/this.width,(innerHeight-16)/this.height);this.width=size*this.width,this.height=size*this.height,this.delegate.getCanvas().width=this.width,this.delegate.getCanvas().style.width=this.delegate.getCanvas().width+"px",this.delegate.getCanvas().height=this.height,this.delegate.getCanvas().style.height=this.delegate.getCanvas().height+"px"}))()}}class GeneratableScreen extends CanvasScreen{init(){this.canvas=document.createElement("canvas"),document.body.appendChild(this.canvas);const style=document.createElement("style");style.append("canvas {display:block;width: "+this.width+"px;height: "+this.height+"px;margin: 0px auto;}"),document.head.appendChild(style),this.canvas.width=this.width,this.canvas.height=this.height,this.canvas.setAttribute("style","canvas")}}class ScalableScreen extends DelegateScreen{init(){super.init(),(window.onresize=(()=>{this.gameSize=Math.min((innerWidth-16)/this.width,(innerHeight-16)/this.height),this.delegate.getCanvas().width=this.gameSize*this.width,this.delegate.getCanvas().style.width=this.delegate.getCanvas().width+"px",this.delegate.getCanvas().height=this.gameSize*this.height,this.delegate.getCanvas().style.height=this.delegate.getCanvas().height+"px"}))()}}class AttackObjectAI extends AI{constructor(){super(),this.actor=null,this.preActorX=0,this.preActorY=0}init(){BaseUtil.implementsOf(this.entity,IOwned)&&(this.actor=this.entity.getOwner(),null!==this.actor&&(this.preActorX=this.actor.x,this.preActorY=this.actor.y))}apply(dt){null!==this.actor&&(this.entity.deltaMove(this.actor.x-this.preActorX,this.actor.y-this.preActorY),this.preActorX=this.actor.x,this.preActorY=this.actor.y);for(const it of this.entity.collider.collisions){const entity=Util.getCollidedEntity(this.entity,it);this.actor!==entity&&BaseUtil.implementsOf(entity,IDamagable)&&entity.damage(1)}return!0}}class StraightAttackAI extends AI{constructor(maxVelocityX,maxVelocityY,movePowerX,movePowerY){super(),this.maxVelocityX=maxVelocityX,this.maxVelocityY=maxVelocityY,this.movePowerX=movePowerX,this.movePowerY=movePowerY,this.actor=null}init(){BaseUtil.implementsOf(this.entity,IOwned)&&(this.actor=this.entity.getOwner())}apply(dt){(this.entity.body.velocityX*this.entity.directionX<0||Math.abs(this.entity.body.velocityX)<Math.abs(this.maxVelocityX))&&this.entity.body.enforce(this.movePowerX*this.entity.material.mass*this.entity.directionX/dt,0),(this.entity.body.velocityY*this.entity.directionY<0||Math.abs(this.entity.body.velocityY)<Math.abs(this.maxVelocityY))&&this.entity.body.enforce(0,this.movePowerY*this.entity.material.mass*this.entity.directionY/dt);for(const it of this.entity.collider.collisions){const entity=Util.getCollidedEntity(this.entity,it);this.actor!==entity&&(BaseUtil.implementsOf(entity,IDamagable)&&entity.damage(1),BaseUtil.implementsOf(this.entity,IBreakable)&&this.entity.destroy())}return!0}}class EnemyAI extends AI{constructor(baseAI){super(),this.baseAI=baseAI,this.preDirectionX=0,this.preDirectionY=0}setEntity(entity){super.setEntity(entity),this.baseAI.setEntity(entity)}init(){this.baseAI.init()}update(dt){this.baseAI.update(dt),this.preDirectionX=this.entity.directionX,this.preDirectionY=this.entity.directionY}apply(dt){if(this.baseAI.apply(dt)){for(const it of this.entity.collider.collisions)if(it.colliding===this.entity&&it.nx*this.preDirectionX+it.ny*this.preDirectionY>0||it.collided===this.entity&&it.nx*this.preDirectionX+it.ny*this.preDirectionY<0){const opponent=Util.getCollidedEntity(this.entity,it);BaseUtil.implementsOf(opponent,IDamagable)&&BaseUtil.implementsOf(opponent,IPlayable)&&opponent.damage(1)}return!0}return!1}}class ElevatorAI extends AI{constructor(maxVelocity,movePower){super(),this.maxVelocity=maxVelocity,this.movePower=movePower,this.floor=-1,this.elevatorXList=[],this.elevatorYList=[],this.onPlayer=!1,this.isMoving=!1,this.notOnPlayercount=0}addPosition(x,y){this.elevatorXList.push(x),this.elevatorYList.push(y)}init(){let x=this.entity.x,y=this.entity.y;for(let i=0;i<this.elevatorXList.length;++i)x+=this.elevatorXList[i],y+=this.elevatorYList[i],this.elevatorXList[i]=x,this.elevatorYList[i]=y}apply(dt){let localCheck=!1;for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(BaseUtil.implementsOf(you,IPlayable)){this.isMoving||this.onPlayer||(this.floor=(this.floor+1)%this.elevatorXList.length,this.isMoving=!0,this.notOnPlayercount=0),localCheck=!0;break}}if(localCheck||(this.notOnPlayercount+=dt/1e3),(localCheck||this.onPlayer&&this.notOnPlayercount>.5)&&(this.onPlayer=localCheck),this.isMoving){let dx=this.elevatorXList[this.floor]-this.entity.x,dy=this.elevatorYList[this.floor]-this.entity.y;const d=Math.sqrt(dx*dx+dy*dy);if(dx*this.entity.directionX<0&&(dx=0,this.entity.setDirection(0),this.entity.body.setNextAddVelocity(-this.entity.body.velocityX,0)),dy*this.entity.directionY<0&&(dy=0,this.entity.setDirection(void 0,0),this.entity.body.setNextAddVelocity(0,-this.entity.body.velocityY)),0===dx&&0===dy)return this.isMoving=!1,!0;this.entity.setDirection(Math.sign(dx),Math.sign(dy));const fx=Math.abs(this.entity.body.velocityX)<this.maxVelocity?dx/d*this.movePower*this.entity.material.mass:0,fy=Math.abs(this.entity.body.velocityY)<this.maxVelocity?dy/d*this.movePower*this.entity.material.mass:0;this.entity.body.enforce(fx,fy)}return!0}}class ShowState extends State{constructor(showTime){super(),this.showTime=showTime,this.showCount=0}init(){this.entity.collider.enable=!0,this.showCount=0,this.canRendering=!0}apply(dt){return this.showCount+=dt/1e3,this.showCount>=this.showTime&&this.ai.changeState("interval"),!0}render(ctx,shiftX=0,shiftY=0){this.canRendering=!1,this.entity.render(ctx,shiftX,shiftY),this.canRendering=!0}}class VanishState extends State{constructor(hideTime,isShowingNext){super(),this.hideTime=hideTime,this.isShowingNext=isShowingNext,this.hideCount=0}init(){this.entity.collider.enable=!1,this.hideCount=0,this.canRendering=!0}apply(dt){return this.hideCount+=dt/1e3,this.hideCount>=this.hideTime&&this.ai.changeState(this.isShowingNext?"show":"vanish"),!0}}class JumpAI extends AI{constructor(jumpPower){super(),this.jumpPower=jumpPower,this.onGroundCount=0,this.jumpedCount=0}update(dt){Util.onGround(this.entity)?(this.entity.getImage().init(),this.onGroundCount+=dt/1e3,this.jumpedCount-=dt/1e3):(this.jumpedCount=1,this.onGroundCount=0)}apply(dt){return this.onGroundCount>1&&this.jumpedCount<=0&&this.entity.body.enforce(0,-this.jumpPower*this.entity.material.mass*1e3/dt),!0}}class NamedStateAI extends StateAI{constructor(id){super(),this.state=null,this.stateName=id,this.namedStates={}}init(){const state=this.stateName;this.stateName="",this.changeState(state)}getState(){return this.state}getStateID(){return this.stateName}setState(state,id){this.namedStates[id]=state}changeState(id){return id!==this.stateName&&(void 0!==this.namedStates[id]&&(this.stateName=id,this.state=this.namedStates[id],super.changeState(id),!0))}}class PlayerBaseStateAI extends NamedStateAI{constructor(){super("stationary"),this.namedStates.stationary=new PStationaryState(300,36e3),this.namedStates.walk=new PWalkState(300,18e3),this.namedStates.jump=new PJumpState(230),this.namedStates.walkjump=new PJumpState(300),this.namedStates.jumping=new PJumpingState(200,12e3),this.namedStates.attack=new PPunchState}}class PlayerGameoverStateAI extends NamedStateAI{constructor(){super("gameover"),this.namedStates.gameover=new PGameoverState}}class BaseState extends State{init(){const image=this.entity.getImage();image instanceof NamedAnimation&&(image.setName(this.ai.getStateID()),image.init())}}class NoneState extends State{apply(dt){return!0}}class StraightAI extends AI{constructor(mvx,px){super(),this.maxVelocityX=mvx,this.walkPower=px}apply(dt){return!Util.onGround(this.entity)||(Util.getSideEntity(this.entity)&&this.entity.setDirection(-1*this.entity.directionX),Math.abs(this.entity.body.velocityX)<this.maxVelocityX&&this.entity.body.enforce(this.entity.directionX*this.walkPower*this.entity.material.mass,0),!0)}}class ImageBackground extends Background{constructor(backImage){super(),this.backImage=backImage}init(){this.backImage.init()}update(dt){this.backImage.update(dt)}}class InvariantBackground extends ImageBackground{render(ctx,shiftX,shiftY,screenWidth,screenHeight){this.backImage.render(ctx,0,0)}}class MovementBackground extends ImageBackground{constructor(backImage,x,y,speedRatioX,speedRatioY){super(backImage),this.x=x,this.y=y,this.speedRatioX=speedRatioX,this.speedRatioY=speedRatioY}render(ctx,shiftX,shiftY,screenWidth,screenHeight){this.backImage.render(ctx,this.x+shiftX*this.speedRatioX,this.y+shiftY*this.speedRatioY)}}class SequentialBackground extends Background{constructor(){super(),this.backs=[]}addBackground(back){this.backs.push(back)}init(){for(const it of this.backs)it.init()}update(dt){for(const it of this.backs)it.update(dt)}render(ctx,shiftX,shiftY,screenWidth,screenHeight){for(const back of this.backs)back.render(ctx,shiftX,shiftY,screenWidth,screenHeight)}}class CenterCamera extends Camera{init(x,y){this.update(x,y,0)}update(x,y,dt){this.cameraX=this.screenWidth/2-x,this.cameraY=this.screenHeight/2-y}}class ClipCamera extends DelegateCamera{init(x,y){super.init(x,y),this.clip()}update(x,y,dt){super.update(x,y,dt),this.clip()}clip(){this.cameraX=this.baseCamera.cameraX,this.cameraY=this.baseCamera.cameraY,this.cameraX<this.screenWidth-this.maxWidth&&(this.cameraX=this.screenWidth-this.maxWidth),this.cameraX>0&&(this.cameraX=0),this.cameraY>0&&(this.cameraY=0),this.cameraY<this.screenHeight-this.maxHeight&&(this.cameraY=this.screenHeight-this.maxHeight),this.baseCamera.cameraX=this.cameraX,this.baseCamera.cameraY=this.cameraY}}class EventCamera extends DelegateCamera{constructor(baseCamera){super(baseCamera),this.toX=0,this.toY=0}setToPosition(x,y){this.toX=x,this.toY=y}update(x,y,dt){super.update(this.toX,this.toY,dt),this.cameraX=this.baseCamera.cameraX,this.cameraY=this.baseCamera.cameraY}}class FixCamera extends Camera{constructor(x,y){super(),this.fixX=x,this.fixY=y}init(x,y){this.update(x,y,0)}update(x,y,dt){this.cameraY=-this.fixX,this.cameraY=-this.fixY}}class ForceMoveCamera extends DelegateCamera{constructor(baseCamera,x,y,speed){super(baseCamera),this.toX=x,this.toY=y,this.speed=speed,this.nextX=0,this.nextY=0}init(x,y){super.init(x,y),this.nextX=this.cameraY,this.nextY=this.cameraX}update(x,y,dt){super.update(this.nextX,this.nextY,dt),this.cameraX=this.baseCamera.cameraX,this.cameraY=this.baseCamera.cameraY;const nx=this.nextX,ny=this.nextY;this.nextX!==this.toX&&(this.nextX=this.nextX+this.speed*dt/1e3*Math.sign(this.toX-this.nextX)),Math.sign(this.toX-nx)*Math.sign(this.toX-this.nextX)<0&&(this.nextX=this.toX),this.nextY!==this.toY&&(this.nextY=this.nextY+this.speed*dt/1e3*Math.sign(this.toY-this.nextY)),Math.sign(this.toY-ny)*Math.sign(this.toY-this.nextY)<0&&(this.nextY=this.toY)}}class MovingCamera extends DelegateCamera{update(x,y,dt){super.update(x,y,dt),this.cameraX===this.baseCamera.cameraX&&this.cameraY===this.baseCamera.cameraY||(this.cameraX=this.cameraX+(this.baseCamera.cameraX-this.cameraX)*dt/200,this.cameraY=this.cameraY+(this.baseCamera.cameraY-this.cameraY)*dt/200)}}class ImmutableEvent extends Entity{constructor(){super(),this.event=null,this.collided=!1,this.eventCollider=null}setEvent(event){this.event=event}getEvent(){return this.event}fire(){BaseUtil.implementsOf(this.event,IStageEvent)&&this.event.setStage(this.stage),EventManager.it.register(this.event)}setCollider(collider){this.eventCollider=collider,this.eventCollider.setEntity(this),this.eventCollider.init()}getCollider(){return this.eventCollider}init(){this.eventCollider.update()}update(dt){super.update(dt);let localCollided=!1;for(const it of this.stage.getPhysicalWorld().getCollisionData(this.eventCollider)){const you=Util.getCollidedEntity(this,it);if(BaseUtil.implementsOf(you,IPlayable)&&(localCollided=!0,!this.collided)){this.fire();break}}this.collided=localCollided}}class OnceEventEntity extends ImmutableEvent{destroy(){this.stage.removeEntity(this)}fire(){BaseUtil.implementsOf(this.event,IStageEvent)&&this.event.setStage(this.stage),EventManager.it.register(this.event),this.destroy()}}class DoorObject extends ImagedEntity{constructor(transition=null,isReplace=!1,popNumber=0){super(),this.transition=transition,this.isReplace=isReplace,this.popNumber=popNumber,this.doorCollider=null,this.isTransitioning=!1}setCollider(collider){this.doorCollider=collider,this.doorCollider.setEntity(this),this.doorCollider.init()}getCollider(){return this.doorCollider}init(){this.doorCollider.update()}update(dt){if(this.isTransitioning){if(super.update(dt),Util.canEnd(this.image)){Input.key.setInputEnable(!0);for(let i=0;i<this.popNumber;++i)StageManager.it.popStage();null!==this.transition&&(this.isReplace?StageManager.it.replaceStage(this.transition):StageManager.it.pushStage(this.transition)),this.isTransitioning=!1}}else if(Input.key.isPress(Input.key.up()))for(const it of this.stage.getPhysicalWorld().getCollisionData(this.doorCollider)){const you=Util.getCollidedEntity(this,it);BaseUtil.implementsOf(you,IPlayable)&&Util.onGround(you)&&(this.isTransitioning=!0,Input.key.setInputEnable(!1))}}}class SignObject extends ImagedEntity{constructor(){super(),this.signImage=null,this.signX=0,this.signY=0,this.signCollider=null,this.isShowSign=!1,this.speed=100}setSign(signImage,x,y){this.signImage=signImage,this.signX=x,this.signY=y}setCollider(collider){this.signCollider=collider,this.signCollider.setEntity(this),this.signCollider.init()}getCollider(){return this.signCollider}init(){this.signCollider.init(),null!==this.signImage&&this.signImage.init(),this.isShowSign=!1}update(dt){this.isShowSign=!1;for(const it of this.stage.getPhysicalWorld().getCollisionData(this.signCollider)){const you=Util.getCollidedEntity(this,it);if(BaseUtil.implementsOf(you,IPlayable)){this.isShowSign=!0;break}}this.isShowSign?(super.update(dt),null!==this.signImage&&Util.canEnd(this.image)&&this.signImage.update(dt)):null!==this.signImage&&this.signImage.init()}render(ctx,shiftX=0,shiftY=0){super.render(ctx,shiftX,shiftY),null!==this.signImage&&this.isShowSign&&Util.canEnd(this.image)&&this.signImage.render(ctx,this.x+shiftX+this.signX,this.y+shiftY+this.signY)}}class Obstacle extends MutableEntity{}class OnlyImageEntity extends ImagedEntity{}class BaseImageBuilder extends ImageBuilder{build(root,image){let ret=null;const id=void 0===image.file?-1:ResourceManager.image.load(`${root}/${image.file}`);switch(image.type){case"tile":{const width=void 0===image.w?image.width:image.w,height=void 0===image.h?image.height:image.h;ret=new TileImage(id,width,height,image.x,image.y,image.width,image.height);break}case"single":ret=new SingleImage(id,image.width,image.height);break;case"anime":ret=new SingleAnimation(image.loop);break;case"multianime":ret=new MultiNamedAnimation}if(void 0!==image.transition)switch(image.transition.type){case"blink":ret instanceof NamedAnimation&&(ret=new TransitionalNamedAnimation(ret,image.transition.time,image.transition.interval));break;case"stripe":ret instanceof NamedAnimation&&(ret=new TransitionalStripeAnimation(ret,image.transition.time),image.clip=!0)}if(image.clip&&(ret instanceof NamedAnimation||(ret instanceof GameAnimation?ret=new ClipAnimation(ret):ret instanceof GameImage&&(ret=new ClipImage(ret)))),image.directional&&(ret instanceof NamedAnimation?ret=new DirectionalNamedAnimation(ret):ret instanceof GameAnimation?ret=new DirectionalAnimation(ret):ret instanceof GameImage&&(ret=new DirectionalImage(ret))),ret instanceof MultiAnimation){for(const anime of image.animations){ret.setName(anime.name),anime.type="anime",anime.directional=image.directional,anime.clip=image.clip;const element=this.build(root,anime);element instanceof GameAnimation&&ret.setAnimation(element)}ret.setAllImageID(id),ret.setAllSize(image.width,image.height)}else if(ret instanceof GameAnimation){for(const it of image.animation)it.type="tile",it.directional=image.directional,it.clip=image.clip,ret.addAnimation(this.build(root,it),it.delta);ret.setImageID(id),ret.setSize(image.width,image.height)}return ret}}class CSVStageParser extends StageParser{makeBaseStage(width,height){return new SplitManagementStage(width,height)}makeBaseBackground(imageID){return new InvariantBackground(imageID)}makeBaseCamera(width,height){return new CenterCamera(width,height)}makeBaseWorld(){const world=new SequentialWorld;return world.setResponse(new RepulsionResponse),world}makeTileObject(verticalId,horizontalId,tileWidth,tileHeight,x,y,width,height,imageID){const tile=new TileObject(horizontalId*tileWidth,verticalId*tileHeight,tileWidth,tileHeight,x,y,width,height,imageID);return tile.setCollider(new RectangleCollider(0,0,width,height)),tile.setMaterial(new ImmutableMaterial),tile}parse(filePath,width,height){const req=new XMLHttpRequest;req.open("GET",filePath,!1),req.send(null);const lines=req.responseText.split("\n"),stageBaseData=lines[0].split(","),tileBaseData=lines[1].split(","),stageData=lines[2].split(","),backID=ResourceManager.image.load("back/"+stageBaseData[0]),stageWidth=parseInt(stageBaseData[1]),stageHeight=parseInt(stageBaseData[2]),tileID=ResourceManager.image.load("tile/"+tileBaseData[0]),tileWidth=parseInt(tileBaseData[1]),tileHeight=parseInt(tileBaseData[2]),tileHorizontalNumber=parseInt(tileBaseData[3]),stage=this.makeBaseStage(stageWidth*tileWidth,stageHeight*tileHeight);stage.setBackground(this.makeBaseBackground(backID)),stage.setCamera(this.makeBaseCamera(width,height)),stage.setPhysicalWorld(this.makeBaseWorld());for(const y=0;y<stageHeight;++y)for(const x=0;x<stageWidth;++x){const id=parseInt(stageData[x+y*stageWidth]);id>-1&&stage.addEntity(this.makeTileObject(Math.floor(id/tileHorizontalNumber),id%tileHorizontalNumber,tileWidth,tileHeight,x*tileWidth,y*tileHeight,tileWidth,tileHeight,tileID))}return stage}}class JSONEntityFactory extends EntityFactory{constructor(tile=new TileBuilder,chara=new CharacterBuilder,event=new SimpleEventBuilder,image=new BaseImageBuilder){super(),this.tileBuilder=tile,this.characterBuilder=chara,this.eventBuilder=event,this.imageBuilder=image,this.tileInfo={},this.entityInfo={},this.tileBuilder.setImageBuilder(image),this.characterBuilder.setImageBuilder(image),this.eventBuilder.setImageBuilder(image)}addEntityInfo(entityInfo){this.buildEntityInfo(entityInfo)}addTileInfo(tileInfo){this.buildTileInfo(tileInfo)}overrideValue(base,data){for(let it in data)data.hasOwnProperty(it)&&(void 0===base[it]||base[it]instanceof Array||!isNaN(base[it])||null===data[it]?base[it]=null===data[it]?void 0:data[it]:this.overrideValue(base[it],data[it]))}buildEntityInfo(entityInfo){const defaultCollider={type:"Rectangle",startX:0,startY:0,width:0,height:0},defaultMaterial={mass:10,elasticity:.1,mu:.65},defaultBBody={type:"MaxAdopt",material:{type:"Immutable",k:.5,frictionX:1,frictionY:0}};for(const entity of entityInfo.entities){if(void 0===entity.collider&&(entity.collider=JSON.parse(JSON.stringify(defaultCollider)),entity.collider.width=entity.width,entity.collider.height=entity.height),void 0===entity.material&&(entity.material=JSON.parse(JSON.stringify(defaultMaterial))),void 0===entity.body&&(entity.body=JSON.parse(JSON.stringify(defaultBBody))),void 0!==entity.image&&"anime"===entity.image.type){const animation=[];for(const it of entity.image.animation)if(it.serial)for(let cy=0;cy<it.vertical;++cy)for(let cx=0;cx<it.horizontal;++cx){const data=JSON.parse(JSON.stringify(it));data.x=it.x+cx*it.width,data.y=it.y+cy*it.height,animation.push(data)}else animation.push(it);entity.image.animation=animation}if(void 0!==entity.image&&"multianime"===entity.image.type){const animations=[];for(const it of entity.image.animations)if(it.serial&&void 0!==it.names){const animation=[];let index=0,number=0;for(let cy=0;cy<it.vertical;++cy)for(let cx=0;cx<it.horizontal;++cx){const data={};if(data.x=it.x+cx*it.width,data.y=it.y+cy*it.height,data.width=it.width,data.height=it.height,data.delta=it.delta,animation.push(data),++number===it.number){for(let i=0;i<it.names[index].length;++i){const item={};if(item.name=it.names[index][i],item.loop=it.loops[index][i],void 0!==it.deltas)for(const anime of animation)anime.delta=it.deltas[index][i];item.animation=JSON.parse(JSON.stringify(animation)),animations.push(item)}animation.length=[],number=0,index++}}}else{const animation=[];for(const e of it.animation)if(e.serial)for(let cy=0;cy<e.vertical;++cy)for(let cx=0;cx<e.horizontal;++cx){const data=JSON.parse(JSON.stringify(e));data.x=e.x+cx*e.width,data.y=e.y+cy*e.height,animation.push(data)}else animation.push(e);it.animation=animation,animations.push(it)}entity.image.animations=animations}this.entityInfo[entity.id]=entity}}buildChipSerial(data,chip){}buildTileInfo(tileInfo){const defaultCollider={type:"Rectangle",startX:0,startY:0,width:0,height:0},defaultMaterial={mass:10,elasticity:.1,mu:.65};for(const tile of tileInfo.tiles)for(const chip of tile.chips)if(void 0===this.tileInfo[chip.id]&&void 0===chip.collider&&(chip.collider=JSON.parse(JSON.stringify(defaultCollider)),chip.collider.width=chip.width,chip.collider.height=chip.height),void 0===this.tileInfo[chip.id]&&void 0===chip.material&&(chip.material=JSON.parse(JSON.stringify(defaultMaterial))),chip.serial){let id=chip.id;const x=chip.image.x,y=chip.image.y;for(let cy=0;cy<chip.vertical;++cy)for(let cx=0;cx<chip.horizontal;++cx){const data=JSON.parse(JSON.stringify(chip));data.id=id,data.image.file=tile.file,data.image.x=x+cx*chip.image.width,data.image.y=y+cy*chip.image.height,this.buildChipSerial(data,chip),void 0===this.tileInfo[id]?this.tileInfo[id]=data:this.overrideValue(this.tileInfo[id],data),++id}}else void 0===this.tileInfo[chip.id]?(chip.image.file=tile.file,this.tileInfo[chip.id]=chip):this.overrideValue(this.tileInfo[chip.id],chip)}buildEvent(base,deploy){if(BaseUtil.implementsOf(base,IEventEntity)){let event=void 0===deploy||void 0===deploy.event?info.event:deploy.event;base.setEvent(this.eventBuilder.build(event))}}createEntity(id,deploy){let ret=null,info=null;return void 0!==this.tileInfo[id]?(info=this.tileInfo[id],ret=this.tileBuilder.build(deploy,info)):(info=this.entityInfo[id],ret=this.characterBuilder.build(deploy,info)),this.buildEvent(ret,deploy),ret}}class JSONStageParser extends StageParser{constructor(image=new BaseImageBuilder){super(),this.imageBuilder=image}makeBackgroundImage(image){return this.imageBuilder.build("back",image)}makeBaseStage(stage){return new SplitManagementStage(stage.width,stage.height)}makeBackground(back){switch(back.type){case"Sequential":const ret=new SequentialBackground;for(const it of back.backs)ret.addBackground(this.makeBackground(it));return ret;case"Invariant":return new InvariantBackground(this.makeBackgroundImage(back.image));case"Movement":return new MovementBackground(this.makeBackgroundImage(back.image),back.x,back.y,back.rx,back.ry);case"Area":return new AreaBackground(this.makeBackgroundImage(back.image),back.x,back.y,back.width,back.height);case"Fixed":return new FixedBackground(this.makeBackgroundImage(back.image),back.x,back.y);default:return null}}makeBaseCamera(camera){let ret=null;return"center"===camera.type&&(ret=new CenterCamera),camera.cliping&&(ret=new ClipCamera(ret)),camera.moving&&(ret=new MovingCamera(ret)),camera.force&&(ret=new ForceMoveCamera(ret,camera.force.x,camera.force.y,camera.force.speed)),ret}makeBaseWorld(stage,world){switch(world.type){case"sequential":return new SequentialWorld;case"split":return new SplitWorld(stage.width,stage.height);case"gravity":{const ret=new VariableGravityWorld(stage.width,stage.height);for(const it of world.gravity)ret.addGravity(it.x,it.y,it.delta);return ret}default:return null}}makePhysicalResponse(){return new RepulsionResponse}makeEntityFactory(stage){const ret=new JSONEntityFactory;for(const it of stage.tiles)ret.addTileInfo(JSON.parse(Util.loadFile(`src/res/stage/${it}`)));for(const it of stage.entities)ret.addEntityInfo(JSON.parse(Util.loadFile(`src/res/stage/${it}`)));return ret}parse(filePath,width,height){const stage=JSON.parse(Util.loadFile(filePath)),base=this.makeBaseStage(stage);base.setBackground(this.makeBackground(stage.background)),base.setCamera(this.makeBaseCamera(stage.camera)),base.getCamera().setScreenSize(width,height),base.getCamera().setMaxSize(base.getStageWidth(),base.getStageHeight()),base.setPhysicalWorld(this.makeBaseWorld(stage,stage.world)),base.getPhysicalWorld().setResponse(this.makePhysicalResponse()),base.setFactory(this.makeEntityFactory(stage));let layerIndex=0;for(const layer of stage.layers){for(const chip of layer)void 0===chip.z&&(chip.z=layerIndex),base.addEntityByID(chip.id,chip);layerIndex+=1}for(const entity of stage.deploy)void 0===entity.z&&(entity.z=layerIndex),base.addEntityByID(entity.id,entity);return base}}class TileBuilder extends EntityBuilder{makeImage(image){return this.imageBuilder.build("tile",image)}tryReplace(deploy,json,data){return void 0===deploy||void 0===deploy[data]?json[data]:deploy[data]}makeCollider(collider){switch(collider.type){case"Rectangle":return new RectangleCollider(collider.startX,collider.startY,collider.width,collider.height);case"Circle":return new CircleCollider(ret.radius,ret.shiftX,ret.shiftY);case"RoundRectangle":return new RoundRectangleCollider(collider.startX,collider.startY,collider.width,collider.height,collider.cut);default:return null}}makeAABB(collider){return collider.directional?new DirectionalAABB:new SimpleAABB}makeMaterial(material){return void 0!==material?new ImmutableMaterial(material.mass,material.elasticity,material.mu):null}makeTileBase(deploy,tile){switch(tile.type){case"image":return new OnlyImageEntity;case void 0:return new TileObject;default:return null}}buildBase(base,deploy,json){void 0!==deploy&&base.setPosition(deploy.x,deploy.y,deploy.z),base.setSize(this.tryReplace(deploy,json,"width"),this.tryReplace(deploy,json,"height"))}buildImage(base,deploy,json){const image=this.tryReplace(deploy,json,"image");void 0!==image&&base.setImage(this.makeImage(image))}buildPhysical(base,deploy,json){const colliderData=this.tryReplace(deploy,json,"collider"),materialData=this.tryReplace(deploy,json,"material");if(void 0!==colliderData){const collider=this.makeCollider(colliderData);null!==collider&&(collider.enable=void 0===colliderData.enable||colliderData.enable,collider.response=void 0===colliderData.response||colliderData.response,collider.setAABB(this.makeAABB(colliderData))),base.setCollider(collider),base.setMaterial(this.makeMaterial(materialData))}}build(deploy,json){const base=this.makeTileBase(deploy,json);return this.buildBase(base,deploy,json),base instanceof ImagedEntity&&this.buildImage(base,deploy,json),base instanceof InfluentialEntity&&this.buildPhysical(base,deploy,json),base}}class IJoint extends Interface{joint(jointed,jointedX,jointedY,length){}unjoint(){}}class ImmutableRigidMaterial extends RigidMaterial{constructor(k=.5,frictionX=1,frictionY=0,g=1){super(),this.kVal=k,this.frictionXVal=frictionX,this.frictionYVal=frictionY,this.gVal=g}get k(){return this.kVal}get frictionX(){return this.frictionXVal}get frictionY(){return this.frictionYVal}get gravityScale(){return this.gVal}}class MaxAdoptBody extends RigidBody{constructor(){super(),this.internalAccelerationX=0,this.internalAccelerationY=0,this.vpx=0,this.vpy=0,this.vmx=0,this.vmy=0,this.preX=0,this.preY=0}setNextAddVelocity(vx,vy){vx>0?this.vpx=Math.max(this.vpx,vx):this.vmx=Math.min(this.vmx,vx),vy>0?this.vpy=Math.max(this.vpy,vy):this.vmy=Math.min(this.vmy,vy)}reset(){super.reset(),this.internalVelocityX=0,this.internalVelocityY=0,this.internalAccelerationX=0,this.internalAccelerationY=0,this.vpx=0,this.vpy=0,this.vmx=0,this.vmy=0}enforce(forceX,forceY){this.internalAccelerationX+=forceX/this.entity.material.mass,this.internalAccelerationY+=forceY/this.entity.material.mass}updateInfo(dt){this.diffX=1e3*(this.entity.x-this.preX)/dt,this.diffY=1e3*(this.entity.y-this.preY)/dt,this.isFixX=Math.abs(this.diffX)<25,this.isFixY=Math.abs(this.diffY)<50,this.preX=this.entity.x,this.preY=this.entity.y}updateVelocity(dt){this.material.velocityX+=this.vpx+this.vmx,this.material.velocityY+=this.vpy+this.vmy,this.material.velocityX+=this.internalAccelerationX*dt/1e3,this.material.velocityY+=this.internalAccelerationY*dt/1e3;const kx=-this.material.velocityX*this.material.k/this.entity.material.mass*dt/1e3,ky=-this.material.velocityY*this.material.k/this.entity.material.mass*dt/1e3;Math.abs(this.material.velocityX)<Math.abs(kx)?this.material.velocityX=0:this.material.velocityX+=kx,Math.abs(this.material.velocityY)<Math.abs(ky)?this.material.velocityY=0:this.material.velocityY+=ky}updateEntity(dt){const dx=this.material.velocityX*dt/1e3,dy=this.material.velocityY*dt/1e3;this.entity.deltaMove(dx,dy)}cleanup(dt){this.material.accelerationX=this.internalAccelerationX,this.material.accelerationY=this.internalAccelerationY,this.internalAccelerationX=0,this.internalAccelerationY=0,this.vpx=0,this.vpy=0,this.vmx=0,this.vmy=0}}class MutableRigidMaterial extends ImmutableRigidMaterial{get k(){return this.kVal}get frictionX(){return this.frictionXVal}get frictionY(){return this.frictionYVal}get gravityScale(){return this.gVal}set k(val){this.kVal=val}set frictionX(val){this.frictionXVal=val}set frictionY(val){this.frictionYVal=val}set gravityScale(val){this.gVal=val}}class PlayerBody extends MaxAdoptBody{}class PreciseBody extends MaxAdoptBody{updateEntity(dt){let dx=this.velocityX*dt/1e3,dy=this.velocityY*dt/1e3;const max=Math.floor(Math.max(Math.abs(dx),Math.abs(dy)));if(0!==max)for(let i=0;i<max;++i){this.entity.deltaMove(dx/max,dy/max);for(const it of this.entity.stage.getPhysicalWorld().getCollisionData(this.entity.collider))it.colliding.collider.isResponse(it.collided.collider)&&it.collided.collider.isResponse(it.colliding.collider)&&(it.nx*dx>0&&(dx=0),it.ny*dy>0&&(dy=0));if(0===dx&&0===dy)break}else this.entity.deltaMove(dx,dy)}}class CircleCollider extends Collider{constructor(radius,shiftX=0,shiftY=0){super(),this.radius=radius,this.shiftX=shiftX,this.shiftY=shiftY,this.centerX=0,this.centerY=0,this.update()}isInCollider(x,y){const sx=this.centerX-x,sy=this.centerY-y;return sx*sx+sy*sy<=this.radius*this.radius}isCollision(collider,data=null){if(collider instanceof CircleCollider){let nx=collider.centerX-this.centerX,ny=collider.centerY-this.centerY;const r=this.radius+collider.radius;if(nx*nx+ny*ny<r*r){if(null!==data){let me=this.entity,you=collider.entity;const nlen=Math.sqrt(nx*nx+ny*ny);nx/=nlen,ny/=nlen;const px=this.centerX+this.radius*nx,py=this.centerY+this.radius*ny,depth=r-nlen;if(me instanceof MutableEntity&&me.body.velocityX*nx+me.body.velocityY*ny>0);else if(you instanceof MutableEntity&&you.body.velocityX*nx+you.body.velocityY*ny<0){const swap=me;me=you,you=swap,nx=-nx,ny=-ny}else(!me instanceof MutableEntity||!you instanceof InfluentialEntity)&&console.log("Error: Colliding entity should be mutable and collided entity should be influential");data.register(me,you,nx,ny,px,py,depth)}return!0}}return!1}fixBound(startX,startY,endX,endY){this.shiftX=startX,this.shiftY=startY,this.radius=Math.max(endX-startX,endY-startY)/2,this.update()}update(){this.aabb.update(this.shiftX,this.shiftY,2*this.radius+this.shiftX,2*this.radius+this.shiftY,this.entity),this.centerX=this.entity.x+this.radius+this.shiftX,this.centerY=this.entity.y+this.radius+this.shiftY}render(ctx,shiftX,shiftY){ctx.strokeCircle(this.centerX+shiftX,this.centerY+shiftY,this.radius,0,2*Math.PI,!1);let me=0,you=0;for(const it of this.collisions)it.colliding===this.entity?me+=1:you+=1;0===me&&0===you||(ctx.fillText(me+"",this.aabb.startX+shiftX+15,this.aabb.startY+shiftY,0,0,15,"blue"),ctx.fillText(you+"",this.aabb.startX+shiftX,this.aabb.startY+shiftY+15,0,0,15,"red"));for(const it of this.collisions)it.e2!==this.entity&&ctx.strokeLine(this.aabb.startX+shiftX+(this.endX-this.startX)/2,this.aabb.startY+shiftY+(this.endY-this.startY)/2,this.aabb.startX+shiftX+(this.endX-this.startX)/2+30*it.nx*(it.colliding===this.entity?1:-1),this.aabb.startY+shiftY+(this.endY-this.startY)/2+30*it.ny*(it.colliding===this.entity?1:-1),"red")}}class LowerPriorityData extends CollisionData{constructor(){super(null,null,0,0,0,0,0)}init(){super.init(),this.py=-1e9}calcPriority(){return this.py}}class RectangleCollider extends Collider{constructor(startX,startY,width,height){super(),this.startX=startX,this.startY=startY,this.endX=startX+width,this.endY=startY+height}isInCollider(x,y){return this.aabb.startX<x&&x<this.aabb.endX&&this.aabb.startY<y&&y<this.aabb.endY}isCollision(collider,data=null){if(collider instanceof RoundRectangleCollider)return collider.isCollision(this,data);if(collider instanceof RectangleCollider){const sx=this.aabb.endX-collider.aabb.startX,ex=this.aabb.startX-collider.aabb.endX,sy=this.aabb.endY-collider.aabb.startY,ey=this.aabb.startY-collider.aabb.endY;if(0<sx&&ex<0&&0<sy&&ey<0){if(null!==data){let me=this.entity,you=collider.entity,nx=Math.abs(sx)<Math.abs(ex)?sx:ex,ny=Math.abs(sy)<Math.abs(ey)?sy:ey,depth=0;if(me instanceof MutableEntity&&me.body.velocityX*nx+me.body.velocityY*ny>0);else if(you instanceof MutableEntity&&you.body.velocityX*nx+you.body.velocityY*ny<0){const swap=me;me=you,you=swap,nx=-nx,ny=-ny}else(!me instanceof MutableEntity||!you instanceof InfluentialEntity)&&console.log("Error: Colliding entity should be mutable and collided entity should be influential");me instanceof MutableEntity&&Math.abs(Math.abs(nx)-Math.abs(ny))<1&&(me.body.velocityX*nx<=0&&(nx=Math.abs(ny)+1),me.body.velocityY*ny<=0&&(ny=Math.abs(nx)+1)),Math.abs(nx)<Math.abs(ny)?(depth=Math.abs(nx),nx=Math.sign(nx),ny=0):(depth=Math.abs(ny),nx=0,ny=Math.sign(ny));const px=me.x+nx*depth,py=me.y+ny*depth;data.register(me,you,nx,ny,px,py,depth)}return!0}}return!1}fixBound(startX,startY,endX,endY){this.startX=startX,this.startY=startY,this.endX=endX,this.endY=endY,this.update()}update(){this.aabb.update(this.startX,this.startY,this.endX,this.endY,this.entity)}render(ctx,shiftX,shiftY){ctx.strokeRect(this.aabb.startX+shiftX,this.aabb.startY+shiftY,this.endX-this.startX,this.endY-this.startY);let me=0,you=0;for(const it of this.collisions)it.colliding===this.entity?me+=1:you+=1;0===me&&0===you||(ctx.fillText(me+"",this.aabb.startX+shiftX+15,this.aabb.startY+shiftY,0,0,15,"blue"),ctx.fillText(you+"",this.aabb.startX+shiftX,this.aabb.startY+shiftY+15,0,0,15,"red"));for(const it of this.collisions)it.collided!==this.entity&&ctx.strokeLine(this.aabb.startX+shiftX+(this.endX-this.startX)/2,this.aabb.startY+shiftY+(this.endY-this.startY)/2,this.aabb.startX+shiftX+(this.endX-this.startX)/2+30*it.nx*(it.colliding===this.entity?1:-1),this.aabb.startY+shiftY+(this.endY-this.startY)/2+30*it.ny*(it.colliding===this.entity?1:-1),"red")}}class RoundRectangleCollider extends RectangleCollider{constructor(startX,startY,width,height,cut){super(startX,startY,width,height),this.cut=cut}isCollision(collider,data=null){if(collider instanceof RoundRectangleCollider){const cutX=this.cut,cutY=this.cut,cutCX=0,cutCY=0;let nx=0,ny=0,d=Number.MAX_SAFE_INTEGER,collided=!1,sx=this.aabb.endX-cutX-collider.aabb.startX-cutCX,ex=this.aabb.startX+cutX-collider.aabb.endX+cutCX,sy=this.aabb.endY-collider.aabb.startY,ey=this.aabb.startY-collider.aabb.endY,len=Math.abs(sy)<Math.abs(ey)?sy:ey;if(0<sx&&ex<0&&0<sy&&ey<0&&(d=Math.abs(len),nx=0,ny=Math.sign(len),collided=!0),sx=this.aabb.endX-cutX-collider.aabb.startX,ex=this.aabb.startX+cutX-collider.aabb.endX,sy=this.aabb.endY-collider.aabb.startY-cutCY,ey=this.aabb.startY-collider.aabb.endY+cutCY,len=Math.abs(sx)<Math.abs(ex)?sx:ex,0<sx&&ex<0&&0<sy&&ey<0&&Math.abs(len)<d&&(d=Math.abs(len),nx=Math.sign(len),ny=0,collided=!0),sx=this.aabb.endX-collider.aabb.startX-cutCX,ex=this.aabb.startX-collider.aabb.endX+cutCX,sy=this.aabb.endY-cutY-collider.aabb.startY,ey=this.aabb.startY+cutY-collider.aabb.endY,len=Math.abs(sx)<Math.abs(ex)?sx:ex,0<sx&&ex<0&&0<sy&&ey<0&&Math.abs(len)<d&&(d=Math.abs(len),nx=Math.sign(len),ny=0,collided=!0),sx=this.aabb.endX-collider.aabb.startX,ex=this.aabb.startX-collider.aabb.endX,sy=this.aabb.endY-cutY-collider.aabb.startY-cutCY,ey=this.aabb.startY+cutY-collider.aabb.endY+cutCY,len=Math.abs(sx)<Math.abs(ex)?sx:ex,0<sx&&ex<0&&0<sy&&ey<0&&Math.abs(len)<d&&(d=Math.abs(len),nx=Math.sign(len),ny=0,collided=!0),collided){if(null!==data){let me=this.entity,you=collider.entity;if(me instanceof MutableEntity&&me.body.velocityX*nx+me.body.velocityY*ny>0);else if(you instanceof MutableEntity&&you.body.velocityX*nx+you.body.velocityY*ny<0){const swap=me;me=you,you=swap,nx=-nx,ny=-ny}else(!me instanceof MutableEntity||!you instanceof InfluentialEntity)&&console.log("Error: Colliding entity should be mutable");const px=me.x+nx*d,py=me.y+ny*d;data.register(me,you,nx,ny,px,py,d)}return!0}}else if(collider instanceof RectangleCollider){const cutX=this.cut,cutY=this.cut;let nx=0,ny=0,d=Number.MAX_SAFE_INTEGER,collided=!1,sx=this.aabb.endX-cutX-collider.aabb.startX,ex=this.aabb.startX+cutX-collider.aabb.endX,sy=this.aabb.endY-collider.aabb.startY,ey=this.aabb.startY-collider.aabb.endY,len=Math.abs(sy)<Math.abs(ey)?sy:ey;if(0<sx&&ex<0&&0<sy&&ey<0&&(d=Math.abs(len),nx=0,ny=Math.sign(len),collided=!0),sx=this.aabb.endX-collider.aabb.startX,ex=this.aabb.startX-collider.aabb.endX,sy=this.aabb.endY-cutY-collider.aabb.startY,ey=this.aabb.startY+cutY-collider.aabb.endY,len=Math.abs(sx)<Math.abs(ex)?sx:ex,0<sx&&ex<0&&0<sy&&ey<0&&Math.abs(len)<d&&(d=Math.abs(len),nx=Math.sign(len),ny=0,collided=!0),collided){if(null!==data){let me=this.entity,you=collider.entity;if(me instanceof MutableEntity&&me.body.velocityX*nx+me.body.velocityY*ny>0);else if(you instanceof MutableEntity&&you.body.velocityX*nx+you.body.velocityY*ny<0){const swap=me;me=you,you=swap,nx=-nx,ny=-ny}else(!me instanceof MutableEntity||!you instanceof InfluentialEntity)&&console.log("Error: Colliding entity should be mutable and collided entity should be influential");const px=me.x+nx*d,py=me.y+ny*d;data.register(me,you,nx,ny,px,py,d)}return!0}}return!1}render(ctx,shiftX,shiftY){ctx.strokeLine(this.aabb.startX+this.cut+shiftX,this.aabb.startY+shiftY,this.aabb.endX-this.cut+shiftX,this.aabb.startY+shiftY),ctx.strokeLine(this.aabb.startX+shiftX,this.aabb.startY+this.cut+shiftY,this.aabb.startX+shiftX,this.aabb.endY-this.cut+shiftY),ctx.strokeLine(this.aabb.endX+shiftX,this.aabb.startY+this.cut+shiftY,this.aabb.endX+shiftX,this.aabb.endY-this.cut+shiftY),ctx.strokeLine(this.aabb.startX+this.cut+shiftX,this.aabb.endY+shiftY,this.aabb.endX-this.cut+shiftX,this.aabb.endY+shiftY);let me=0,you=0;for(const it of this.collisions)it.colliding===this.entity?me+=1:you+=1;0===me&&0===you||(ctx.fillText(me+"",this.aabb.startX+shiftX+15,this.aabb.startY+shiftY,0,0,15,"blue"),ctx.fillText(you+"",this.aabb.startX+shiftX,this.aabb.startY+shiftY+15,0,0,15,"red"));for(const it of this.collisions)it.collided!==this.entity&&ctx.strokeLine(this.aabb.startX+shiftX+(this.endX-this.startX)/2,this.aabb.startY+shiftY+(this.endY-this.startY)/2,this.aabb.startX+shiftX+(this.endX-this.startX)/2+30*it.nx*(it.colliding===this.entity?1:-1),this.aabb.startY+shiftY+(this.endY-this.startY)/2+30*it.ny*(it.colliding===this.entity?1:-1),"red")}}class SimpleAABB extends AABB{constructor(startX=0,startY=0,endX=0,endY=0){super(),this.startXVal=startX,this.startYVal=startY,this.endXVal=endX,this.endYVal=endY}get startX(){return this.startXVal}get startY(){return this.startYVal}get endX(){return this.endXVal}get endY(){return this.endYVal}update(startX,startY,endX,endY,entity){this.startXVal=entity.x+startX,this.startYVal=entity.y+startY,this.endXVal=entity.x+endX,this.endYVal=entity.y+endY}}class ImpulseBasedResponse extends CollisionResponse{collisionResponse(data,dt){const nx=data.nx,ny=data.ny,d=600*data.depth,e1=data.colliding,e2=data.collided,b1=e1.body;if(e2 instanceof MutableEntity){const b2=e2.body,dot1=b1.velocityX*nx+b1.velocityY*ny,dot2=b2.velocityX*nx+b2.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny,v2x=dot2*nx,v2y=dot2*ny,vdx=v2x-v1x,vdy=v2y-v1y,m1=e1.material.mass,m2=e2.material.mass,e=Math.max(e1.material.e,e2.material.e),n1=e1.collider.collisions.length,n2=e2.collider.collisions.length,j=(1+e)*m1*m2/(m1+m2)*1e3/dt,j1=j/n1,j2=j/n2,d1=d/n1,d2=d/n2;b1.enforce(j1*vdx-d1*nx,j1*vdy-d1*ny),b2.enforce(-j2*vdx+d2*nx,-j2*vdy+d2*ny)}else{const dot1=b1.velocityX*nx+b1.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny,m1=e1.material.mass,e=e1.material.e,n1=e1.collider.collisions.length,j=(1+e)*m1*1e3/-dt/n1,dd=d/n1*4;b1.enforce(j*v1x-dd*nx,j*v1y-dd*ny)}}}class ImmutableMaterial extends Material{constructor(mass=10,elasticity=.1,mu=.6){super(),this.massVal=mass,this.eVal=elasticity,this.muVal=mu}get mass(){return this.massVal}get e(){return this.eVal}get mu(){return this.muVal}}class RepulsionResponse extends CollisionResponse{collisionResponse(data,dt){const e1=data.colliding,e2=data.collided,b1=e1.body;let b2=null;const nx=data.nx,ny=data.ny,d=data.depth;if(b1.velocityX*nx+b1.velocityY*ny<=0){if(d<1e-4)return;if(e2 instanceof MutableEntity){const nm1=d/5,n1x=-nx*nm1,n1y=-ny*nm1,nm2=d/100,n2x=nx*nm2,n2y=ny*nm2;let i=0;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y),e2.deltaMove(n2x,n2y)}else{let i=0;const n1x=-nx*d/10,n1y=-ny*d/10;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y)}return}let vdx1=0,vdy1=0,vdx2=0,vdy2=0;if(e2 instanceof MutableEntity&&(ny<1||b1.velocityX*e2.body.velocityX+b1.velocityY*e2.body.velocityY<0)){b2=e2.body;const dot1=b1.velocityX*nx+b1.velocityY*ny,dot2=b2.velocityX*nx+b2.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny,v2x=dot2*nx,v2y=dot2*ny,v1=v1x*v1x+v1y*v1y,v2=v2x*v2x+v2y*v2y;if(d>1e-4){let i=0;const nm1=d/5,n1x=-nx*nm1,n1y=-ny*nm1,nm2=d/100,n2x=b2.isFixX?0:nx*nm2,n2y=b2.isFixY?0:ny*nm2;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y),e2.deltaMove(n2x,n2y)}if(Math.abs(v1)<Math.abs(v2)&&dot2>=0)return;const e=(e1.material.e+e2.material.e)/2;vdx1=(v2x-v1x)*(1+e)*e2.material.mass/(e1.material.mass+e2.material.mass),vdy1=(v2y-v1y)*(1+e)*e2.material.mass/(e1.material.mass+e2.material.mass),vdx2=-(v2x-v1x)*(1+e)*e1.material.mass/(e1.material.mass+e2.material.mass),vdy2=-(v2y-v1y)*(1+e)*e1.material.mass/(e1.material.mass+e2.material.mass)}else{const dot1=b1.velocityX*nx+b1.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny;if(d>1e-4){let i=0;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(-nx*d/10,-ny*d/10)}const e=e2.material.e;vdx1=-v1x*(1+e),vdy1=-v1y*(1+e)}if(e1.collider.getAABB().startY<e2.collider.getAABB().startY){const mu=e2.material.mu,dotp=b1.accelerationX*nx+b1.accelerationY*ny,px=dotp*nx,py=dotp*ny,p=Math.sqrt(px*px+py*py);let dvx=0,dvy=0;const ovx=null===b2||b2.isFixX||b2.diffX*b2.velocityX<0?b1.velocityX:b1.diffX-b2.diffX,ovy=null===b2||b2.isFixY||b2.diffY*b2.velocityY<0?b1.velocityY:b1.diffY-b2.diffY,dot=Math.sign(ovx*-ny+ovy*nx);dvx=dot*-ny*p*mu*dt/1e3,dvy=dot*nx*p*mu*dt/1e3,ovx===b1.velocityX&&Math.abs(dvx)>Math.abs(b1.velocityX)&&(dvx=b1.velocityX),ovy===b1.velocityY&&Math.abs(dvy)>Math.abs(b1.velocityY)&&(dvy=b1.velocityY),vdx1-=dvx*b1.material.frictionX,vdy1-=dvy<0?0:dvy*b1.material.frictionY}else if(null!==b2){const mu=e1.material.mu,dotp=b2.accelerationX*nx+b2.accelerationY*ny,px=dotp*nx,py=dotp*ny,p=Math.sqrt(px*px+py*py);let dvx=0,dvy=0;const ovx=b1.isFixX||b1.diffX*b1.velocityX<0?b2.velocityX:b2.diffX-b1.diffX,ovy=b1.isFixY||b1.diffY*b1.velocityY<0?b2.velocityY:b2.diffY-b1.diffY,dot=Math.sign(ovx*-ny+ovy*nx);dvx=dot*-ny*p*mu*dt/1e3,dvy=dot*nx*p*mu*dt/1e3,ovx===b2.velocityX&&Math.abs(dvx)>Math.abs(b2.velocityX)&&(dvx=b2.velocityX),ovy===b2.velocityY&&Math.abs(dvy)>Math.abs(b2.velocityY)&&(dvy=b2.velocityY),vdx2-=dvx*b2.material.frictionX,vdy2-=dvy<0?0:dvy*b2.material.frictionY}b1.setNextAddVelocity(vdx1,vdy1),null!==b2&&b2.setNextAddVelocity(vdx2,vdy2)}}class SequentialWorld extends PhysicalWorld{constructor(gravity=9.8){super(gravity),this.collisions=[],this.collisionSize=0,this.actors=[],this.notActors=[],this.entities=[];for(let i=0;i<100;++i){const data=new LowerPriorityData;data.init(),this.collisions.push(data)}}addEntity(entity){this.entities.push(entity),entity instanceof MutableEntity?this.actors.push(entity):this.notActors.push(entity)}removeEntity(entity){let index=this.entities.indexOf(entity);index>=0&&this.entities.splice(index,1),(index=this.actors.indexOf(entity))>=0&&this.actors.splice(index,1),(index=this.notActors.indexOf(entity))>=0&&this.notActors.splice(index,1)}getCollisionData(collider){const ret=[];if(null===collider)return ret;const data=new LowerPriorityData;for(const it of this.entities){const itCollider=it.collider;null!==itCollider&&it!==collider.entity&&itCollider.enable&&(collider.isCollisionRoughly(itCollider)&&collider.isCollision(itCollider,data)&&(ret.push(data),data=new LowerPriorityData))}return ret}getCollisionSize(){return this.collisionSize}updateExternalForce(dt){for(const target of this.actors)null!==target.body&&target.body.enforce(0,this.gravity*target.material.mass*target.body.material.gravityScale)}prepareBody(dt){for(const target of this.actors)null!==target.body&&target.body.prepare(dt)}updateBody(dt){for(const target of this.actors)null!==target.body&&target.body.update(dt)}updateBodyCleanup(dt){for(const target of this.actors)null!==target.body&&target.body.cleanup(dt)}initCollision(dt){for(let j=0;j<this.collisionSize;++j)this.collisions[j].init();this.collisionSize=0;for(const it of this.entities)null!==it.collider&&it.collider.init()}updateCollision(dt){for(let i=0;i<this.actors.length;++i){const target=this.actors[i],targetCollider=target.collider;if(null!==targetCollider&&targetCollider.enable){for(let j=i+1;j<this.actors.length;++j){const it=this.actors[j],itCollider=it.collider;if(null!==itCollider&&itCollider.enable&&targetCollider.isCollisionRoughly(itCollider)&&targetCollider.isCollision(itCollider,this.collisions[this.collisionSize])&&(targetCollider.addCollision(this.collisions[this.collisionSize]),itCollider.addCollision(this.collisions[this.collisionSize]),++this.collisionSize>=this.collisions.length)){const data=new LowerPriorityData;data.init(),this.collisions.push(data)}}for(const it of this.notActors){const itCollider=it.collider;if(null!==itCollider&&itCollider.enable&&targetCollider.isCollisionRoughly(itCollider)&&targetCollider.isCollision(itCollider,this.collisions[this.collisionSize])&&(targetCollider.addCollision(this.collisions[this.collisionSize]),itCollider.addCollision(this.collisions[this.collisionSize]),++this.collisionSize>=this.collisions.length)){const data=new LowerPriorityData;data.init(),this.collisions.push(data)}}}}}updateResponse(dt){for(let j=0;j<this.collisionSize;++j){const it=this.collisions[j];it.colliding.collider.isResponse(it.collided.collider)&&it.collided.collider.isResponse(it.colliding.collider)&&this.response.collisionResponse(it,dt)}}}class SplitWorld extends SequentialWorld{constructor(stageWidth,stageHeight,gravity=9.8,splitNumber=128){super(gravity),this.splitNumber=splitNumber,this.stageWidth=Math.floor(stageWidth/this.splitNumber)+(stageWidth%this.splitNumber==0?0:1),this.stageHeight=Math.floor(stageHeight/this.splitNumber)+(stageHeight%this.splitNumber==0?0:1),this.notActorsMap=[];for(let y=0;y<this.stageHeight+1;++y)for(let x=0;x<this.stageWidth+1;++x)this.notActorsMap.push([])}addEntity(entity){if(this.entities.push(entity),entity instanceof MutableEntity)this.actors.push(entity);else{const sx=Math.floor(entity.collider.aabb.startX/this.splitNumber),sy=Math.floor(entity.collider.aabb.startY/this.splitNumber),ex=Math.floor(entity.collider.aabb.endX/this.splitNumber),ey=Math.floor(entity.collider.aabb.endY/this.splitNumber);for(let y=sy;y<=ey;++y)for(let x=sx;x<=ex;++x)this.notActorsMap[x+this.stageWidth*y].push(entity);this.notActors.push(entity)}}removeEntity(entity){let index=this.entities.indexOf(entity);if(index>=0&&this.entities.splice(index,1),(index=this.actors.indexOf(entity))>=0&&this.actors.splice(index,1),(index=this.notActors.indexOf(entity))>=0){this.notActors.splice(index,1);const sx=Math.floor(entity.collider.aabb.startX/this.splitNumber),sy=Math.floor(entity.collider.aabb.startY/this.splitNumber),ex=Math.floor(entity.collider.aabb.endX/this.splitNumber),ey=Math.floor(entity.collider.aabb.endY/this.splitNumber);for(let y=sy;y<=ey;++y)for(let x=sx;x<=ex;++x)this.notActorsMap[x+this.stageWidth*y].splice(this.notActorsMap[x+this.stageWidth*y].indexOf(entity),1)}}getCollisionData(collider){const ret=[];if(null===collider)return ret;let sx=Math.floor(collider.aabb.startX/this.splitNumber),sy=Math.floor(collider.aabb.startY/this.splitNumber);const ex=Math.floor(collider.aabb.endX/this.splitNumber),ey=Math.floor(collider.aabb.endY/this.splitNumber);if(ex<0||ey<0||sx>=this.stageWidth||sy>=this.stageHeight)return ret;sx<0&&(sx=0),sy<0&&(sy=0);const collidedList=[];let data=new LowerPriorityData;for(const it of this.actors){const itCollider=it.collider;null!==itCollider&&it!==collider.entity&&itCollider.enable&&(collider.isCollisionRoughly(itCollider)&&collider.isCollision(itCollider,data)&&(ret.push(data),data=new LowerPriorityData))}for(let y=sy;y<=ey;++y)for(let x=sx;x<=ex;++x)for(const it of this.notActorsMap[x+this.stageWidth*y]){const itCollider=it.collider;null!==itCollider&&itCollider.enable&&(-1===collidedList.indexOf(it)&&collider.isCollisionRoughly(itCollider)&&collider.isCollision(itCollider,data)&&(collidedList.push(it),ret.push(data),data=new LowerPriorityData))}return ret}updateCollision(dt){for(let i=0;i<this.actors.length;++i){const target=this.actors[i],targetCollider=target.collider;if(null===targetCollider||!targetCollider.enable)continue;let sx=Math.floor(targetCollider.aabb.startX/this.splitNumber),sy=Math.floor(targetCollider.aabb.startY/this.splitNumber);const ex=Math.floor(targetCollider.aabb.endX/this.splitNumber),ey=Math.floor(targetCollider.aabb.endY/this.splitNumber);if(ex<0||ey<0||sx>=this.stageWidth||sy>=this.stageHeight)continue;sx<0&&(sx=0),sy<0&&(sy=0);const collidedList=[];for(let j=i+1;j<this.actors.length;++j){const it=this.actors[j],itCollider=it.collider;null!==itCollider&&itCollider.enable&&targetCollider.isCollisionRoughly(itCollider)&&targetCollider.isCollision(itCollider,this.collisions[this.collisionSize])&&(targetCollider.addCollision(this.collisions[this.collisionSize]),itCollider.addCollision(this.collisions[this.collisionSize]),++this.collisionSize>=this.collisions.length&&this.collisions.push(new LowerPriorityData))}for(let y=sy;y<=ey;++y)for(let x=sx;x<=ex;++x)for(const it of this.notActorsMap[x+this.stageWidth*y]){const itCollider=it.collider;null!==itCollider&&itCollider.enable&&-1===collidedList.indexOf(it)&&targetCollider.isCollisionRoughly(itCollider)&&targetCollider.isCollision(itCollider,this.collisions[this.collisionSize])&&(collidedList.push(it),targetCollider.addCollision(this.collisions[this.collisionSize]),itCollider.addCollision(this.collisions[this.collisionSize]),++this.collisionSize>=this.collisions.length&&this.collisions.push(new LowerPriorityData))}}}}class VariableGravityWorld extends SplitWorld{constructor(stageWidth,stageHeight,gravity=9.8){super(stageWidth,stageHeight,gravity),this.gravityX=0,this.gravityY=1,this.gravityXs=[],this.gravityYs=[],this.deltas=[],this.number=0}addGravity(gravityX,gravityY,delta){this.gravityXs.push(gravityX),this.gravityYs.push(gravityY),this.deltas.push(delta)}updateExternalForce(dt){this.deltas[this.number]<0&&this.number++,this.number<this.deltas.length&&(this.gravityX=this.gravityXs[this.number],this.gravityY=this.gravityYs[this.number],this.deltas[this.number]-=dt/1e3,this.deltas[this.number]<1&&(this.gravityX=0,this.gravityY=1));for(const target of this.actors)if(null!==target.body){const g=this.gravity*target.material.mass*target.body.material.gravityScale;target.body.enforce(g*this.gravityX,g*this.gravityY)}}render(ctx,shiftX=0,shiftY=0){if(this.number<this.deltas.length){const delta=this.deltas[this.number];if(delta<1&&Math.floor(1e3*delta)%2==0&&this.number<this.deltas.length-1){const x=this.gravityXs[this.number+1],y=this.gravityYs[this.number+1];x>0&&ctx.fillText(">",GameScreen.it.width-10,GameScreen.it.height/2,1,.5,100,"red"),x<0&&ctx.fillText("<",10,GameScreen.it.height/2,0,.5,100,"red"),y>0&&ctx.fillText("|",GameScreen.it.width/2,GameScreen.it.height-10,.5,1,100,"red"),y<0&&ctx.fillText("^",GameScreen.it.width/2,10,.5,0,100,"red")}}}}class SplitManagementStage extends Stage{constructor(stageWidth,stageHeight){super(stageWidth,stageHeight),this.entities=[],this.sortedEntity=[],this.removeList=[],this.player=null,this.inited=!1}init(){if(this.inited=!0,this.sortedEntity=Object.assign([],this.entities).sort((a,b)=>a.z<b.z?-1:a.z>b.z?1:0),null!==this.player){const x=this.player.getCameraX(),y=this.player.getCameraY();this.camera.init(x,y)}}addEntity(entity){if(null===this.player&&BaseUtil.implementsOf(entity,IPlayable)&&(this.player=entity),entity instanceof InfluentialEntity&&this.physic.addEntity(entity),this.entities.push(entity),super.addEntity(entity),this.inited){const index=this.sortedEntity.findIndex(it=>entity.z<it.z);index>=0?this.sortedEntity.splice(index,0,entity):this.sortedEntity.push(entity)}}removeEntity(entity){this.removeList.push(entity)}removeEntityImmediately(entity){entity===this.player&&(this.player=null),entity instanceof InfluentialEntity&&this.physic.removeEntity(entity);let index=this.entities.indexOf(entity);index>=0&&this.entities.splice(index,1),(index=this.sortedEntity.indexOf(entity))>=0&&this.sortedEntity.splice(index,1)}getEntities(){return this.entities}updateEntity(dt){for(const it of this.entities)it.update(dt);for(const entity of this.removeList)this.removeEntityImmediately(entity);this.removeList.length=0}updatePhysics(dt){this.physic.update(dt)}updateBackground(dt){this.back.update(dt)}updateCamera(dt){if(null!==this.player){const x=this.player.getCameraX(),y=this.player.getCameraY();this.camera.update(x,y,dt)}}renderBackground(ctx,shiftX,shiftY){this.back.render(ctx,shiftX+this.camera.cameraX,shiftY+this.camera.cameraY,this.camera.screenWidth,this.camera.screenHeight)}renderEntity(ctx,shiftX,shiftY){const startX=-this.camera.cameraX,startY=-this.camera.cameraY,endX=startX+this.camera.screenWidth,endY=startY+this.camera.screenHeight;for(const it of this.sortedEntity)it.x+it.width>=startX&&it.x<endX&&it.y+it.height>=startY&&it.y<endY&&it.render(ctx,this.camera.baseX-startX,this.camera.baseY-startY)}renderWorld(ctx,shiftX,shiftY){this.physic.render(ctx,shiftX,shiftY)}}class StackStageManager extends StageManager{constructor(){super(),this.stageStack=[]}pushStage(stageName){const stage=this.parser.parse(`src/res/stage/${stageName}.json`,this.width,this.height);this.stageStack.push(stage),stage.init()}popStage(stage){return this.stageStack.pop()}getStage(){return 0===this.stageStack.length?null:this.stageStack[this.stageStack.length-1]}}class SimpleTimer extends Timer{constructor(){super(),this.namedTimer={},this.namedStartTimer={}}startTimer(name){this.namedStartTimer[name]=+new Date}stopTimer(name){this.namedTimer[name]=+new Date-this.namedStartTimer[name]}getTimer(name){return this.namedTimer[name]}render(ctx,x,y){for(const name in this.namedTimer)this.namedTimer.hasOwnProperty(name)&&(ctx.fillText(`${name} : ${this.getTimer(name)} msec`,x,y,0,0,20,"white"),y+=30)}}class UnderEngine extends Engine{constructor(){super(),this.oldTime=+new Date,this._loop=null}update(){const newTime=+new Date;this.timer.update(newTime-this.oldTime),this.input.update(),this.manager.update(this.timer.deltaTime>30?30:this.timer.deltaTime),this.oldTime=newTime}render(){this.context.preRendering(),this.manager.render(this.context),this.context.postRendering()}main(){this.oldTime=+new Date,this._loop=(_=>{requestAnimationFrame(this._loop),this.update(),this.render()}),requestAnimationFrame(this._loop)}}class UnderEngineBuilder extends EngineBuilder{makeEngine(){return new UnderEngine}makeInput(){return new AllInput(new KeyInput,new MouseInput)}makeScreen(){return new DetectiveScreen}makeContext(){return new JSContext}makeImageManager(){return new CachedImage("src/res/image/")}makeMusic(){return new BufferSourceMusic}makeMusicManager(){return new CachedMusic("src/res/sound/")}makeTimer(){return new SimpleTimer}makeSceneManager(){return new StackSceneManager}}class Util{static onGround(entity){return null!==this.getUnderEntity(entity)}static getUnderEntity(entity){const data=entity.collider.collisions.find(it=>(it.colliding===entity&&it.ny>0||it.collided===entity&&it.ny<0)&&it.colliding.collider.isResponse(it.collided.collider)&&it.collided.collider.isResponse(it.colliding.collider));return void 0===data?null:this.getCollidedEntity(entity,data)}static getSideEntity(entity){const list=entity.collider.collisions;for(const it of list){if(0!==it.ny)continue;const dot=entity.body.velocityX*it.nx+entity.body.velocityY*it.ny;if(it.colliding===entity&&dot>0||it.collided===entity&&dot<0)return this.getCollidedEntity(entity,it)}return null}static getCollidedEntity(self,data){return data.colliding===self?data.collided:data.colliding}static loadFile(filePath){const req=new XMLHttpRequest;return req.open("GET",filePath,!1),req.send(null),req.responseText}static renderWindow(ctx,id,x,y,width,height){const imageWidth=ResourceManager.image.getWidth(id)/3,imageHeight=ResourceManager.image.getHeight(id)/3;x=Math.floor(x),y=Math.floor(y),width=Math.floor(width),height=Math.floor(height),ctx.drawImage(id,x,y,imageWidth,imageHeight,0,0,imageWidth,imageHeight),ctx.drawImage(id,x+imageWidth,y,width-2*imageWidth,imageHeight,imageWidth,0,imageWidth,imageHeight),ctx.drawImage(id,x+width-imageWidth,y,imageWidth,imageHeight,2*imageWidth,0,imageWidth,imageHeight),ctx.drawImage(id,x,y+imageHeight,imageWidth,height-2*imageHeight,0,imageHeight,imageWidth,imageHeight),ctx.drawImage(id,x+imageWidth,y+imageHeight,width-2*imageWidth,height-2*imageHeight,imageWidth,imageHeight,imageWidth,imageHeight),ctx.drawImage(id,x+width-imageWidth,y+imageHeight,imageWidth,height-2*imageHeight,2*imageWidth,imageHeight,imageWidth,imageHeight),ctx.drawImage(id,x,y+height-imageHeight,imageWidth,imageHeight,0,2*imageHeight,imageWidth,imageHeight),ctx.drawImage(id,x+imageWidth,y+height-imageHeight,width-2*imageWidth,imageHeight,imageWidth,2*imageHeight,imageWidth,imageHeight),ctx.drawImage(id,x+width-imageWidth,y+height-imageHeight,imageWidth,imageHeight,2*imageWidth,2*imageHeight,imageWidth,imageHeight)}static canEnd(image){return!(image instanceof GameAnimation)||image.isEnded()}static removeIfExists(list,element){const index=list.indexOf(element);return index>=0&&list.splice(index,1),index}}class LinkEvent extends GameEvent{constructor(url){super(),this.url=url}init(){this.op.next(),null!==Input.key&&Input.key.clear(),null!==Input.mouse&&Input.mouse.clear(),window.open(this.url,"_blank")}}class TextWindowEvent extends NamedEvent{constructor(name,x,y,sentence,size=-1){super(name),this.x=x,this.y=y,this.sentence=sentence,this.size=size,this.showCount=0,this.ended=!1}init(){this.showCount=0,this.ended=!1,null!==this.op&&this.op.next()}update(dt){if(this.ended){if(this.showCount-=dt/200,this.showCount<0)return this.showCount=0,!0}else this.showCount+=dt/1e3,this.showCount>1&&(this.showCount=1),1===this.showCount&&Input.key.isPressed(Input.key.yes())&&(this.ended=!0);return!1}render(ctx){const id=ResourceManager.image.load("window/win2.png"),size=(-1===this.size?25:this.size)*this.showCount*this.showCount,width=ctx.measureText(this.sentence,size);Util.renderWindow(ctx,id,this.x-(width+64)/2,this.y-(64+size)/2,width+64,64+size),ctx.fillText(this.sentence,this.x,this.y,.5,.5,size)}}class CameraChangeEvent extends StageEvent{constructor(type,isMoving=!1,isCliping=!1){super(),this.type=type,this.isMoving=isMoving,this.isCliping=isCliping}init(){let camera=null;"center"===this.type&&(camera=new CenterCamera),this.isCliping&&(camera=new ClipCamera(camera)),this.isMoving&&(camera=new MovingCamera(camera));const old=this.stage.getCamera();camera.setScreenSize(old.screenWidth,old.screenHeight),camera.setMaxSize(old.maxWidth,old.maxHeight),this.stage.setCamera(camera),this.op.next()}}class PhysicalChangeEvent extends StageEvent{constructor(response){super(),this.response=response}init(){this.stage.getPhysicalWorld().setResponse(this.response),this.op.next()}}class UnderEventBuilder extends SimpleEventBuilder{makeEvent(event){switch(event.type){case"talkwindow":return new TextWindowEvent(event.name,event.x,event.y,event.sentence,event.size);case"changeCamera":return new CameraChangeEvent(event.camera,event.moving,event.cliping);case"changePhysical":let response=null;switch(event.physical){case"under":response=new UnderRepulsionResponse;break;case"repulsion":response=new RepulsionResponse;break;case"impulse":response=new ImpulseBasedResponse}return new PhysicalChangeEvent(response);case"link":return new LinkEvent(event.url);default:return super.makeEvent(event)}}}class MainBuilder extends UnderEngineBuilder{makeInput(){return new PreventKeyInput}}class UILayer extends Layer{constructor(stage){super(),this.stage=stage,this.player=null,this.playerHP=0,this.uiAnimation=new MultiNamedAnimation}init(){this.player=this.stage.getEntities().find(it=>BaseUtil.implementsOf(it,IPlayable)&&BaseUtil.implementsOf(it,IDamagable)),this.playerHP=this.player.getHP();const uiImage=ResourceManager.image.load("ui/hp.png");for(let i=0;i<6;++i)if(this.uiAnimation.setName(`${3-Math.floor(i/2)%4}-${3-Math.floor((i+1)/2)%4}`),this.uiAnimation.setAnimation(new SingleAnimation(i%2==0)),5!==i)for(let j=0;j<4;++j)this.uiAnimation.addAnimation(new TileImage(uiImage,64,64,32*j,32*i,32,32),i%2==0?300:200);else for(let j=0;j<8;++j)this.uiAnimation.addAnimation(new TileImage(uiImage,64,64,j%4*32,32*(i+Math.floor(j/4)),32,32),200);this.uiAnimation.setName(`${this.player.getHP()}-${this.player.getHP()}`),this.uiAnimation.init()}update(dt){const diff=this.playerHP-this.player.getHP();0!==diff&&(this.uiAnimation.isEnded()||this.uiAnimation.isLoop())?(this.uiAnimation.setName(`${this.playerHP}-${this.playerHP-Math.sign(diff)}`),this.uiAnimation.init(),this.playerHP=this.playerHP-Math.sign(diff)):this.playerHP>0&&0===diff&&this.uiAnimation.isEnded()&&!this.uiAnimation.isLoop()&&(this.uiAnimation.setName(`${this.playerHP}-${this.playerHP}`),this.uiAnimation.init()),this.uiAnimation.update(dt)}render(ctx){this.uiAnimation.render(ctx,this.x+10,this.y+530)}}class TitleScene extends Scene{constructor(){super(),this._title=null}init(){this._title=new SingleImage(ResourceManager.image.load("ui/title.png"),370,120),this._title.init()}update(dt){this._title.update(dt),Input.key.isPress(Input.key.yes())&&SceneManager.it.replaceScene(new GameScene)}render(ctx){this._title.render(ctx,215,240)}}class IMovableState extends Interface{get maxVX(){}get maxVY(){}get movePX(){}get movePY(){}setMaxVelocity(maxVelocityX,maxVelocityY){}setMovePower(movePowerX,movePowerY){}}class IPrepareState extends Interface{set speedMagnification(val){}set appliedPower(val){}get speedMagnification(){}get appliedPower(){}}class HookingState extends State{constructor(){super(),this.hook=null}init(){BaseUtil.implementsOf(this.entity,IHook)&&(this.hook=this.entity)}apply(dt){return null!==this.hook&&this.hook.createPost(),!0}}class HookReleasedState extends State{constructor(hook){super(),this.hook=null}init(){BaseUtil.implementsOf(this.entity,IHook)&&(this.hook=this.entity)}apply(dt){if(null===this.hook)return!0;for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(you===this.hook.getActor()){this.hook.tryRemove();break}}return!0}}class HookStateAI extends NamedStateAI{constructor(){super("hooking"),this.namedStates.hooking=new HookingState,this.namedStates.released=new HookReleasedState}}class TransferableState extends BaseState{transfer(state){}}class TransferableStateAI extends NamedStateAI{transfer(state){for(const name in this.namedStates)if(this.namedStates.hasOwnProperty(name)){const other=state.namedStates[name];other instanceof TransferableState&&this.namedStates[name].transfer(other)}state.stateName=this.stateName}}class IHook extends Interface{getActor(){}createPost(){}hooked(){}release(){}tryRemove(){}isHead(){}}class ITerrain extends Interface{getTerrainID(){}}class TextSignObject extends SignObject{constructor(){super(),this.signText="",this.size=0,this.isExec=!1}setSign(x,y,size,text){super.setSign(null,x,y),this.size=size,this.signText=text}init(){super.init(),this.textWindow=new TextWindowEvent(this.signText,this.x+this.signX,this.y+this.signY,this.signText,this.size)}update(dt){super.update(dt),this.isShowSign&&!this.isExec&&this.textWindow.init(),this.isShowSign&&(Input.key.blockInput(Input.key.sub()),this.textWindow.update(dt),Input.key.unblockInput(Input.key.sub())),!this.isShowSign&&this.isExec&&Input.key.unblockInput(Input.key.sub()),this.isExec=this.isShowSign}render(ctx,shiftX=0,shiftY=0){super.render(ctx,shiftX,shiftY),this.textWindow.x=this.x+this.signX+shiftX,this.textWindow.y=this.y+this.signY+shiftY,this.isShowSign&&this.textWindow.render(ctx)}}class UnderStageParser extends JSONStageParser{makeEntityFactory(stage){const ret=new JSONEntityFactory(new UnderTileBuilder,new UnderCharacterBuilder,new UnderEventBuilder);for(const it of stage.tiles)ret.addTileInfo(JSON.parse(Util.loadFile(`src/res/stage/${it}`)));for(const it of stage.entities)ret.addEntityInfo(JSON.parse(Util.loadFile(`src/res/stage/${it}`)));return ret}makePhysicalResponse(){return new UnderRepulsionResponse}}class UnderTileBuilder extends TileBuilder{makeCollider(collider){if(void 0!==collider&&collider.excluded)switch(collider.type){case"Rectangle":return new ExcludedRectangleCollider(collider.startX,collider.startY,collider.width,collider.height,collider.id);case"RoundRectangle":return new ExcludedRoundRectangleCollider(collider.startX,collider.startY,collider.width,collider.height,collider.cut,collider.id)}return super.makeCollider(collider)}makeTileBase(deploy,tile){switch(tile.type){case void 0:return new UnderTileObject(tile.terrain);default:return super.makeTileBase(deploy,tile)}}}class IString extends Interface{getLength(){}getBodies(){}addBody(jointing,jointingX,jointingY,length){}removeBody(body){}}class StringBody extends RigidBody{constructor(body,jointingX,jointingY,length,k,count){super(),this.body=body,this.jointingList=[],this.jointingXList=[],this.jointingYList=[],this.jointingLengthList=[],this.enableList=[],this.k=k,this.count=count,this.jointingList.push(body),this.jointingXList.push(jointingX),this.jointingYList.push(jointingY),this.jointingLengthList.push(length)}get velocityX(){return this.body.velocityX}get velocityY(){return this.body.velocityY}get accelerationX(){return this.body.accelerationX}get accelerationY(){return this.body.accelerationY}setEntity(entity){super.setEntity(entity),this.body.setEntity(entity)}setMaterial(material){super.setMaterial(material),this.body.setMaterial(material)}reset(){super.reset(),this.body.reset()}setNextAddVelocity(vx,vy){this.body.setNextAddVelocity(vx,vy)}enforce(forceX,forceY){this.body.enforce(forceX,forceY)}init(){this.body.init()}prepare(){for(let i=0;i<this.jointingList.length;++i){const it=this.jointingList[i];this.enableList[i]=it.enable,it.enable=!1}}update(dt){if(!this.enable)return;const collisions=[],listLength=this.jointingLengthList.length,milisec=dt/1e3,milisec2=milisec*milisec,elim=1,world=this.entity.stage.getPhysicalWorld(),dxList=new Array(listLength),dyList=new Array(listLength),willXList=[];willXList.push(new Array(listLength)),willXList.push(new Array(listLength));const willYList=[];willYList.push(new Array(listLength)),willYList.push(new Array(listLength));const pxList=new Array(listLength),pyList=new Array(listLength),movedList=new Array(listLength),xRepulsionList=new Array(listLength),yRepulsionList=new Array(listLength);for(let i=0;i<listLength;++i){const it=this.jointingList[i];if(this.enableList[i]&&(it.updateInfo(dt),it.updateVelocity(dt),it.updateEntity(dt)),dxList[i]=it.entity.directionX>=0?this.jointingXList[i]:it.entity.width-this.jointingXList[i],dyList[i]=it.entity.directionY>=0?this.jointingYList[i]:it.entity.height-this.jointingYList[i],willXList[1][i]=it.entity.x+dxList[i],willYList[1][i]=it.entity.y+dyList[i],pxList[i]=0,pyList[i]=0,xRepulsionList[i]=!1,yRepulsionList[i]=!1,this.enableList[i]){const data=world.getCollisionData(it.entity.collider);for(const col of data)col.colliding.collider.isResponse(col.collided.collider)&&col.collided.collider.isResponse(col.colliding.collider)&&(willXList[1][i]-=col.nx*col.depth,willYList[1][i]-=col.ny*col.depth,it.velocityX*col.nx+it.velocityY*col.ny>0&&(xRepulsionList[i]||(pxList[i]-=col.nx*it.entity.material.mass*Math.abs(it.velocityX)/milisec/2,xRepulsionList[i]=0!==col.nx),yRepulsionList[i]||(pyList[i]-=col.ny*it.entity.material.mass*Math.abs(it.velocityY)/milisec/2,yRepulsionList[i]=0!==col.ny)),collisions.push(col));it.entity.deltaMove(willXList[1][i]-it.entity.x-dxList[i],willYList[1][i]-it.entity.y-dyList[i])}willXList[0][i]=willXList[1][i],willYList[0][i]=willYList[1][i]}let isLoop=!0;for(let count=0;count<this.count&&isLoop;count+=listLength){isLoop=!1;for(let i=0;i<listLength-1;++i){const length=this.jointingLengthList[i+1]+this.jointingLengthList[i],dx=willXList[0][i+1]-willXList[0][i],dy=willYList[0][i+1]-willYList[0][i],d2=dx*dx+dy*dy;if(d2-length*length<1||0===d2)continue;const m1=this.jointingList[i].entity.material.mass,m2=this.jointingList[i+1].entity.material.mass,d=Math.sqrt(d2),power=(d-length)*this.k,px=power*dx/d,py=power*dy/d;this.enableList[i]&&(willXList[1][i]+=px*milisec2/m1,willYList[1][i]+=py*milisec2/m1,movedList[i]=!0),this.enableList[i+1]&&(willXList[1][i+1]-=px*milisec2/m2,willYList[1][i+1]-=py*milisec2/m2,movedList[i+1]=!0),pxList[i]+=px,pyList[i]+=py,pxList[i+1]-=px,pyList[i+1]-=py,isLoop=!0}for(let i=0;i<listLength;++i){if(movedList[i]){const it=this.jointingList[i];it.entity.deltaMove(willXList[1][i]-it.entity.x-dxList[i],willYList[1][i]-it.entity.y-dyList[i]);const data=world.getCollisionData(it.entity.collider);for(const col of data)col.colliding.collider.isResponse(col.collided.collider)&&col.collided.collider.isResponse(col.colliding.collider)&&(willXList[1][i]-=col.nx*col.depth,willYList[1][i]-=col.ny*col.depth,it.velocityX*col.nx+it.velocityY*col.ny>0&&(xRepulsionList[i]||(pxList[i]-=col.nx*it.entity.material.mass*Math.abs(it.velocityX)/milisec/2,xRepulsionList[i]=0!==col.nx),yRepulsionList[i]||(pyList[i]-=col.ny*it.entity.material.mass*Math.abs(it.velocityY)/milisec/2,yRepulsionList[i]=0!==col.ny)),collisions.push(col));willXList[0][i]=willXList[1][i],willYList[0][i]=willYList[1][i]}movedList[i]=!1}}for(let i=0;i<listLength;++i){const it=this.jointingList[i];it.cleanup(dt),this.enableList[i]&&(it.enforce(pxList[i],pyList[i]),it.updateVelocity(dt),it.cleanup(dt)),it.entity.collider.clear()}for(const it of collisions)it.colliding.collider.addCollision(it),it.collided.collider.addCollision(it)}cleanup(dt){for(let i=0;i<this.jointingList.length;++i){const it=this.jointingList[i];it.enable=this.enableList[i]}}getLength(){return this.jointingLengthList[this.jointingLengthList.length-1]}getBodies(){return this.jointingList}addBody(jointing,jointingX,jointingY,length){this.jointingList.push(jointing),this.jointingXList.push(jointingX),this.jointingYList.push(jointingY),this.jointingLengthList.push(length),this.enableList.push(jointing.enable)}removeBody(body){const index=this.jointingList.indexOf(body);index>=0&&(this.jointingList.splice(index,1),this.jointingXList.splice(index,1),this.jointingYList.splice(index,1),this.jointingLengthList.splice(index,1),this.enableList.splice(index,1))}}class ExcludedRectangleCollider extends RectangleCollider{constructor(startX,startY,width,height,targetID){super(startX,startY,width,height),this.targetID=targetID}getTargetID(){return this.targetID}isResponse(collider){return super.isResponse()&&(!BaseUtil.implementsOf(collider,IExclude)||!this.targetID===collider.getTargetID())}}class ExcludedRoundRectangleCollider extends RoundRectangleCollider{constructor(startX,startY,width,height,cut,targetID){super(startX,startY,width,height,cut),this.targetID=targetID}getTargetID(){return this.targetID}isResponse(collider){return super.isResponse()&&(!BaseUtil.implementsOf(collider,IExclude)||!this.targetID===collider.getTargetID())}}class IExclude extends Interface{getTargetID(){}}class UnderRepulsionResponse extends CollisionResponse{collisionResponse(data,dt){const e1=data.colliding,e2=data.collided,b1=e1.body;let b2=null;const nx=data.nx,ny=data.ny,d=data.depth;if(b1.velocityX*nx+b1.velocityY*ny<=0){if(d<1e-4)return;if(e2 instanceof MutableEntity){const nm1=d/5,n1x=-nx*nm1,n1y=-ny*nm1,nm2=d/100,n2x=nx*nm2,n2y=ny*nm2;let i=0;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y),e2.deltaMove(n2x,n2y)}else{let i=0;const n1x=-nx*d/10,n1y=-ny*d/10;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y)}return}let vdx1=0,vdy1=0,vdx2=0,vdy2=0;if(e2 instanceof MutableEntity){b2=e2.body;const dot1=b1.velocityX*nx+b1.velocityY*ny,dot2=b2.velocityX*nx+b2.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny,v2x=dot2*nx,v2y=dot2*ny,v1=v1x*v1x+v1y*v1y,v2=v2x*v2x+v2y*v2y;if(d>1e-4){let i=0;const nm1=d/5,n1x=-nx*nm1,n1y=-ny*nm1,nm2=d/100,n2x=b2.isFixX?0:nx*nm2,n2y=b2.isFixY?0:ny*nm2;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(n1x,n1y),e2.deltaMove(n2x,n2y)}if(Math.abs(v1)<Math.abs(v2)&&dot2>=0)return;const e=(e1.material.e+e2.material.e)/2;vdx1=(v2x-v1x)*(1+e)*e2.material.mass/(e1.material.mass+e2.material.mass),vdy1=(v2y-v1y)*(1+e)*e2.material.mass/(e1.material.mass+e2.material.mass),vdx2=-(v2x-v1x)*(1+e)*e1.material.mass/(e1.material.mass+e2.material.mass),vdy2=-(v2y-v1y)*(1+e)*e1.material.mass/(e1.material.mass+e2.material.mass)}else{const dot1=b1.velocityX*nx+b1.velocityY*ny,v1x=dot1*nx,v1y=dot1*ny;if(d>1e-4){let i=0;for(;i++<10&&e1.collider.isCollision(e2.collider);)e1.deltaMove(-nx*d/10,-ny*d/10)}const e=e2.material.e;vdx1=-v1x*(1+e),vdy1=-v1y*(1+e)}if(e1.collider.getAABB().startY<e2.collider.getAABB().startY){const mu=e2.material.mu,dotp=b1.accelerationX*nx+b1.accelerationY*ny,px=dotp*nx,py=dotp*ny,p=Math.sqrt(px*px+py*py);let dvx=0,dvy=0;const ovx=null===b2||b2.isFixX||b2.diffX*b2.velocityX<0?b1.velocityX:b1.diffX-b2.diffX,ovy=null===b2||b2.isFixY||b2.diffY*b2.velocityY<0?b1.velocityY:b1.diffY-b2.diffY,dot=Math.sign(ovx*-ny+ovy*nx);dvx=dot*-ny*p*mu*dt/1e3,dvy=dot*nx*p*mu*dt/1e3,ovx===b1.velocityX&&Math.abs(dvx)>Math.abs(b1.velocityX)&&(dvx=b1.velocityX),ovy===b1.velocityY&&Math.abs(dvy)>Math.abs(b1.velocityY)&&(dvy=b1.velocityY),vdx1-=dvx*b1.material.frictionX,vdy1-=dvy<0?0:dvy*b1.material.frictionY}else if(null!==b2){const mu=e1.material.mu,dotp=b2.accelerationX*nx+b2.accelerationY*ny,px=dotp*nx,py=dotp*ny,p=Math.sqrt(px*px+py*py);let dvx=0,dvy=0;const ovx=b1.isFixX||b1.diffX*b1.velocityX<0?b2.velocityX:b2.diffX-b1.diffX,ovy=b1.isFixY||b1.diffY*b1.velocityY<0?b2.velocityY:b2.diffY-b1.diffY,dot=Math.sign(ovx*-ny+ovy*nx);dvx=dot*-ny*p*mu*dt/1e3,dvy=dot*nx*p*mu*dt/1e3,ovx===b2.velocityX&&Math.abs(dvx)>Math.abs(b2.velocityX)&&(dvx=b2.velocityX),ovy===b2.velocityY&&Math.abs(dvy)>Math.abs(b2.velocityY)&&(dvy=b2.velocityY),vdx2-=dvx*b2.material.frictionX,vdy2-=dvy<0?0:dvy*b2.material.frictionY}b1.setNextAddVelocity(vdx1,vdy1),null!==b2&&b2.setNextAddVelocity(vdx2,vdy2)}}class IEventOperator extends Interface{next(){}delete(event){}getRunningEvents(){}}class IEventRegister extends Interface{register(event){}unregister(event){}clear(){}}class IStageEvent extends Interface{setStage(stage){}}class IInput extends Interface{clear(){}setInputEnable(enable){}blockInput(code){}unblockInput(code){}press(code){}unpress(code){}isPress(code){}isPressed(code){}}class IKey extends IInput{a(){}zero(){}space(){}right(){}left(){}up(){}down(){}yes(){}no(){}sub(){}}class IMouse extends IInput{mRight(){}mLeft(){}mCenter(){}getMouseX(){}getMouseY(){}}class GameAnimation extends GameImage{isLoop(){}isEnded(){}pause(){}restore(){}getAnimationCount(){}addAnimation(image,delta){}getImages(){}getCurrentImage(){}setSize(width,height){for(const it of this.getImages())it.setSize(width,height)}setImageID(imageID){for(const it of this.getImages())it.setImageID(imageID)}getImageID(){return null===this.getCurrentImage()?0:this.getCurrentImage().getImageID()}getWidth(){return null===this.getCurrentImage()?0:this.getCurrentImage().getWidth()}getHeight(){return null===this.getCurrentImage()?0:this.getCurrentImage().getHeight()}getSourceOffsetX(){return null===this.getCurrentImage()?0:this.getCurrentImage().getSourceOffsetX()}getSourceOffsetY(){return null===this.getCurrentImage()?0:this.getCurrentImage().getSourceOffsetY()}getSourceWidth(){return null===this.getCurrentImage()?0:this.getCurrentImage().getSourceWidth()}getSourceHeight(){return null===this.getCurrentImage()?0:this.getCurrentImage().getSourceHeight()}init(){for(const it of this.getImages())it.init()}update(dt){const image=this.getCurrentImage();null!==image&&image.update(dt)}render(ctx,x,y){const image=this.getCurrentImage();null!==image&&image.render(ctx,x,y)}}class IClipImage extends Interface{setClipArea(clipX,clipY,clipWidth,clipHeight){}}class IDirectionalImage extends Interface{setDirection(directionX,directionY){}}class MultiAnimation extends GameAnimation{getAnimation(){}getAnimations(){}setAnimation(animation){}setAllSize(width,height){for(const it of this.getAnimations())it.setSize(width,height)}setAllImageID(imageID){for(const it of this.getAnimations())it.setImageID(imageID)}isLoop(){const anime=this.getAnimation();return null!==anime&&anime.isLoop()}isEnded(){const anime=this.getAnimation();return null!==anime&&anime.isEnded()}pause(){const anime=this.getAnimation();null!==anime&&anime.pause()}restore(){const anime=this.getAnimation();null!==anime&&anime.restore()}getAnimationCount(){const anime=this.getAnimation();return null!==anime?anime.getAnimationCount():0}addAnimation(image,delta){const anime=this.getAnimation();null!==anime&&anime.addAnimation(image,delta)}getImages(){const anime=this.getAnimation();return null===anime?[]:anime.getImages()}getCurrentImage(){const anime=this.getAnimation();return null===anime?null:anime.getCurrentImage()}init(){const anime=this.getAnimation();null!==anime&&anime.init()}update(dt){const anime=this.getAnimation();null!==anime&&anime.update(dt)}render(ctx,x,y){const anime=this.getAnimation();null!==anime&&anime.render(ctx,x,y)}}class NamedAnimation extends MultiAnimation{setName(name){}}class IResourceManager extends Interface{load(filePath){}unload(id){}reload(){}getPath(id){}}class ClipLayer extends Layer{constructor(){super(),this.clipX=0,this.clipY=0,this.clipWidth=0,this.clipHeight=0}clip(clipX,clipY,clipWidth,clipHeight){this.clipX=clipX,this.clipY=clipY,this.clipWidth=clipWidth,this.clipHeight=clipHeight}}class LayeredScene extends Scene{addLayer(layer){layer.init()}removeLayer(layer){}clearLayer(){for(const it of this.getLayers().reverse())this.removeLayer(it)}getLayers(){}update(dt){for(const layer of this.getLayers())layer.update(dt)}render(ctx){for(const layer of this.getLayers())layer.render(ctx)}}class AutonomyEntity extends MutableEntity{addAI(ai,priority){ai.setEntity(this),ai.init()}removeAI(ai){}updateAI(dt){}applyAI(dt){}update(dt){super.update(dt),this.updateAI(dt),this.applyAI(dt)}}class ImmutableEntity extends InfluentialEntity{}class IBreakable extends Interface{destroy(){}}class IColliderable extends Interface{getCollider(){}}class IDamagable extends IBreakable{getHP(){}damage(damage){}}class IEventEntity extends Interface{setEvent(event){}getEvent(){}fire(){}}class IOwned extends Interface{setOwner(owner){}getOwner(){}}class IPlayable extends Interface{getCameraX(){}getCameraY(){}isGameover(){}}class UnderDebugEngine extends UnderEngine{update(){this.timer.startTimer("overall"),this.timer.startTimer("update"),super.update(),this.timer.stopTimer("update")}render(){this.timer.startTimer("render"),super.render(),this.timer.stopTimer("render"),this.timer.stopTimer("overall")}}class DirectionInputOrder extends InputOrder{constructor(time,directionX,directionY){super(),this.time=time,this.remainingTime=time,this.directionX=directionX,this.directionY=directionY}init(){this.remainingTime=this.time,1===this.directionX?Input.key.press(Input.key.right()):-1===this.directionX&&Input.key.press(Input.key.left()),1===this.directionY?Input.key.press(Input.key.down()):-1===this.directionY&&Input.key.press(Input.key.up())}destruct(){1===this.directionX?Input.key.unpress(Input.key.right()):-1===this.directionX&&Input.key.unpress(Input.key.left()),1===this.directionY?Input.key.unpress(Input.key.down()):-1===this.directionY&&Input.key.unpress(Input.key.up())}udpate(dt){return this.remainingTime-=dt/1e3,1===this.directionX?Input.key.press(Input.key.right()):-1===this.directionX&&Input.key.press(Input.key.left()),1===this.directionY?Input.key.press(Input.key.down()):-1===this.directionY&&Input.key.press(Input.key.up()),this.remainingTime<=0}}class KeyInput extends StateInputManager{a(){return 65}zero(){return 48}space(){return 13}right(){return 39}left(){return 37}up(){return 38}down(){return 40}yes(){return 90}no(){return 88}sub(){return 67}init(){super.init();for(let i=0;i<255;++i)this.inputState.push(this.STATE.NONE);this.target.parentElement.onkeydown=(e=>{this.onKeyDown(e)}),this.target.parentElement.onkeyup=(e=>{this.onKeyUp(e)});const blur=this.target.parentElement.onblur;this.target.parentElement.onblur=(()=>{this.clear(),null!=blur&&blur()})}onKeyDown(e){if(!this.enable)return;const code=e.keyCode;void 0!==this.inputState[code]&&this.inputState[code]!==this.STATE.NONE||(this.inputState[code]=this.STATE.PRESS)}onKeyUp(e){if(!this.enable)return;const code=e.keyCode;this.inputState[code]=this.STATE.NONE}}class MouseInput extends StateInputManager{constructor(){super(),this.mouseX=0,this.mouseY=0}init(){super.init();for(let i=0;i<3;++i)this.inputState.push(this.STATE.NONE);this.target.onmousemove=(e=>{this.onMouseMove(e)}),this.target.onmousedown=(e=>{this.onMouseDown(e)}),this.target.onmouseup=(e=>{this.onMouseUp(e)});const blur=this.target.parentElement.onblur;this.target.parentElement.onblur=(()=>{this.clear(),null!=blur&&blur()}),document.oncontextmenu=function(){return!1}}mRight(){return 2}mLeft(){return 0}mCenter(){return 1}getMouseX(){return this.mouseX}getMouseY(){return this.mouseY}onMouseMove(e){const rect=this.target.getBoundingClientRect();this.mouseX=(e.clientX-rect.left)/this.screen.gameSize,this.mouseY=(e.clientY-rect.top)/this.screen.gameSize}onMouseDown(e){if(!this.enable)return;const button=e.button;void 0!==this.inputState[button]&&this.inputState[button]!==this.STATE.NONE||(this.inputState[button]=this.STATE.PRESS)}onMouseUp(e){if(!this.enable)return;const button=e.button;this.inputState[button]=this.STATE.NONE}}class PreventKeyInput extends KeyInput{prevent(e){const code=e.keyCode;code!==this.up()&&code!==this.down()&&code!==this.right()&&code!==this.left()&&code!==this.yes()&&code!==this.no()&&code!==this.sub()||e.preventDefault()}onKeyDown(e){this.prevent(e),super.onKeyDown(e)}onKeyUp(e){this.prevent(e),super.onKeyUp(e)}}class ClipImage extends DelegateImage{constructor(baseImage){super(baseImage),this.clipX=0,this.clipY=0,this.clipWidth=Number.MAX_SAFE_INTEGER,this.clipHeight=Number.MAX_SAFE_INTEGER}setClipArea(clipX,clipY,clipWidth,clipHeight){this.clipX=clipX,this.clipY=clipY,this.clipWidth=clipWidth,this.clipHeight=clipHeight}render(ctx,x,y){const width=Math.abs(this.getWidth()),height=Math.abs(this.getHeight()),widthPer=this.getSourceWidth()/width,heightPer=this.getSourceHeight()/height,dx=x<this.clipX?this.clipX:x,dy=y<this.clipY?this.clipY:y,dw=this.clipX+this.clipWidth<x+width?this.clipX+this.clipWidth-dx:width-dx+x,dh=this.clipY+this.clipHeight<y+height?this.clipY+this.clipHeight-dy:height-dy+y;let sx=this.getSourceOffsetX()+(x<this.clipX?(this.clipX-x)*widthPer:0);const sy=this.getSourceOffsetY()+(y<this.clipY?(this.clipY-y)*heightPer:0),sw=this.clipX+this.clipWidth<x+width?(this.clipX+this.clipWidth-dx)*widthPer:this.getSourceWidth()-sx+this.getSourceOffsetX(),sh=this.clipY+this.clipHeight<y+height?(this.clipY+this.clipHeight-dy)*heightPer:this.getSourceHeight()-sy+this.getSourceOffsetY();sx-=this.getWidth()>0?0:this.getSourceWidth()-sw,sw>0&&sh>0&&ctx.drawImage(this.getImageID(),dx,dy,dw*Math.sign(this.getWidth()),dh*Math.sign(this.getHeight()),sx,sy,sw,sh)}}class DelegateAnimation extends GameAnimation{constructor(baseAnimation){super(),this.baseAnimation=baseAnimation}setDirection(directionX,directionY){BaseUtil.implementsOf(this.baseAnimation,IDirectionalImage)&&this.baseAnimation.setDirection(directionX,directionY)}setClipArea(clipX,clipY,clipWidth,clipHeight){BaseUtil.implementsOf(this.baseAnimation,IClipImage)&&this.baseAnimation.setClipArea(clipX,clipY,clipWidth,clipHeight)}isLoop(){return this.baseAnimation.isLoop()}isEnded(){return this.baseAnimation.isEnded()}pause(){this.baseAnimation.pause()}restore(){this.baseAnimation.restore()}getAnimationCount(){return this.baseAnimation.getAnimationCount()}addAnimation(image,delta){this.baseAnimation.addAnimation(image,delta)}getImages(){return this.baseAnimation.getImages()}getCurrentImage(){return this.baseAnimation.getCurrentImage()}init(){this.baseAnimation.init()}update(dt){this.baseAnimation.update(dt)}render(ctx,x,y){this.baseAnimation.render(ctx,x,y)}}class DelegateNamedAnimation extends NamedAnimation{constructor(baseAnimation){super(),this.baseAnimation=baseAnimation}setDirection(directionX,directionY){BaseUtil.implementsOf(this.baseAnimation,IDirectionalImage)&&this.baseAnimation.setDirection(directionX,directionY)}setClipArea(clipX,clipY,clipWidth,clipHeight){BaseUtil.implementsOf(this.baseAnimation,IClipImage)&&this.baseAnimation.setClipArea(clipX,clipY,clipWidth,clipHeight)}setName(name){this.baseAnimation.setName(name)}setAllSize(width,height){this.baseAnimation.setAllSize(width,height)}setAllImageID(imageID){this.baseAnimation.setAllImageID(imageID)}getAnimation(){return this.baseAnimation.getAnimation()}getAnimations(){return this.baseAnimation.getAnimations()}setAnimation(animation){this.baseAnimation.setAnimation(animation)}init(){this.baseAnimation.init()}update(dt){this.baseAnimation.update(dt)}render(ctx,x,y){this.baseAnimation.render(ctx,x,y)}}class DirectionalAnimation extends DelegateAnimation{setDirection(directionX,directionY){for(const it of this.getImages())BaseUtil.implementsOf(it,IDirectionalImage)&&it.setDirection(directionX,directionY)}}class DirectionalNamedAnimation extends DelegateNamedAnimation{setDirection(directionX,directionY){for(const it of this.getAnimations())BaseUtil.implementsOf(it,IDirectionalImage)&&it.setDirection(directionX,directionY)}}class MultiNamedAnimation extends NamedAnimation{constructor(){super(),this.animation={},this.name=null}setName(name){this.name=name}getAnimation(){const ret=this.animation[this.name];return void 0!==ret?ret:null}getAnimations(){const list=[];for(const it in this.animation)this.animation.hasOwnProperty(it)&&list.push(this.animation[it]);return list}setAnimation(animation){this.animation[this.name]=animation}}class SingleAnimation extends GameAnimation{constructor(loop=!0){super(),this.animation=[],this.deltas=[],this.animationCount=0,this.runningAnimation=0,this.loop=loop,this.ended=!1,this.paused=!1}isLoop(){return this.loop}isEnded(){return this.ended}pause(){this.paused=!0}restore(){this.paused=!1}getAnimationCount(){return this.runningAnimation/this.animation.length}addAnimation(image,delta){this.animation.push(image),this.deltas.push(delta)}getImages(){return this.animation}getCurrentImage(){return void 0===this.animation[this.runningAnimation]?null:this.animation[this.runningAnimation]}init(){super.init(),this.animationCount=0,this.runningAnimation=0,this.ended=!1}update(dt){if(this.paused||0===this.animation.length)return;if(!this.isLoop()&&this.isEnded())return;super.update(dt);let delta=this.deltas[this.runningAnimation];for(this.animationCount+=dt;this.animationCount>=delta;)this.animationCount-=delta,++this.runningAnimation>=this.animation.length&&(this.ended=!0,this.isLoop()?this.runningAnimation=0:this.runningAnimation--),delta=this.deltas[this.runningAnimation]}}class TransitionalBlinkAnimation extends DelegateNamedAnimation{constructor(baseAnimation,transitionTime,transitionInterval){super(baseAnimation),this.transitionTime=transitionTime,this.transitionInterval=transitionInterval,this.oldImageID=-1,this.transitionID=-1,this.transitionCount=-1}setAllImageID(imageID){-1===this.transitionID?this.transitionID=imageID:this.transitionCount=this.transitionTime,this.oldImageID=this.transitionID,this.transitionID=imageID,super.setAllImageID(imageID)}update(dt){this.transitionCount>0?(this.transitionCount-=dt/1e3,1e3*this.transitionCount%(2*this.transitionInterval)>=this.transitionInterval?super.setAllImageID(this.oldImageID):super.setAllImageID(this.transitionID)):-1!==this.transitionCount&&(this.transitionCount=-1,super.setAllImageID(this.transitionID)),super.update(dt)}}class TransitionalStripeAnimation extends DelegateNamedAnimation{constructor(baseAnimation,transitioTime){super(baseAnimation),this.transitioTime=transitioTime,this.oldImageID=-1,this.transitionID=-1,this.transitionCount=-1}setAllImageID(imageID){-1===this.transitionID?this.transitionID=imageID:this.transitionCount=this.transitioTime,this.oldImageID=this.transitionID,this.transitionID=imageID,super.setAllImageID(imageID)}update(dt){this.transitionCount>0&&(this.transitionCount-=dt/1e3),super.update(dt)}render(ctx,x,y){if(this.transitionCount>0){super.setAllImageID(this.oldImageID);const image=super.getAnimation(),oldHeight=Math.floor(super.getHeight()*(this.transitionCount/this.transitioTime));BaseUtil.implementsOf(image,IClipImage)&&image.setClipArea(x,y,super.getWidth(),oldHeight),super.render(ctx,x,y),super.setAllImageID(this.transitionID);const newHeight=super.getHeight()-oldHeight;BaseUtil.implementsOf(image,IClipImage)&&image.setClipArea(x,y+oldHeight,super.getWidth(),newHeight),super.render(ctx,x,y),BaseUtil.implementsOf(image,IClipImage)&&image.setClipArea(0,0,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)}else super.render(ctx,x,y)}}class BaseLayeredScene extends LayeredScene{constructor(){super(),this.layers=[],this.sortedLayers=[]}addLayer(layer){this.layers.push(layer),super.addLayer(layer);const index=this.sortedLayers.findIndex(it=>layer.z<it.z);index>=0?this.sortedLayers.splice(index,0,layer):this.sortedLayers.push(layer)}removeLayer(layer){let index=this.layers.indexOf(layer);index>=0&&this.layers.splice(index,1),(index=this.sortedLayers.indexOf(layer))>=0&&this.sortedLayers.splice(index,1)}getLayers(){return this.layers}render(ctx){for(const layer of this.sortedLayers)layer.render(ctx)}}class DragScrollLayer extends ScrollLayer{constructor(delegate){super(delegate),this.oldMouseX=0,this.oldMouseY=0,this.scrolling=!1}update(dt){const x=Input.mouse.getMouseX(),y=Input.mouse.getMouseY();this.x<=x&&x<this.x+this.width&&this.y<=y&&y<this.y+this.height&&Input.mouse.isPress(Input.mouse.mRight())&&(this.scrolling=!0,this.oldMouseX=x,this.oldMouseY=y),Input.mouse.isPressed(Input.mouse.mRight())||(this.scrolling=!1),this.scrolling&&(Input.mouse.blockInput(Input.mouse.mRight()),this.scroll(x-this.oldMouseX,y-this.oldMouseY),this.oldMouseX=x,this.oldMouseY=y),super.update(dt)}}class NamedTabbedLayer extends TabbedLayer{constructor(){super(),this.tabNames=[],this.tabLayers=[],this.currentlyTabIndex=0,this.tabX=0,this.tabY=-20,this.tabWidth=70,this.tabHeight=20,this.tabPadding=10}addTab(layer){super.addTab(layer),this.tabLayers.push(layer),this.tabNames.push(layer.toString())}addTabWithName(layer,name){this.addTab(layer),this.tabNames[this.tabNames.length-1]=name}removeTab(layer){const index=this.tabLayers.indexOf(layer);index>=0&&(this.tabLayers.splice(index,1),this.tabNames.splice(index,1))}getTab(){const ret=this.tabLayers[this.currentlyTabIndex];return void 0!==ret?ret:null}getTabs(){return this.tabLayers}update(dt){super.update(dt);const x=Input.mouse.getMouseX()-this.x,y=Input.mouse.getMouseY()-this.y;if(Input.mouse.isPress(Input.mouse.mLeft()))for(let i=0;i<this.tabLayers.length;++i){const sx=this.x+this.tabX+(this.tabWidth+this.tabPadding)*i;if(sx<x&&x<sx+this.tabWidth&&this.tabY<y&&y<this.tabY+this.tabHeight){this.currentlyTabIndex=i;break}}}render(ctx){for(let i=0;i<this.tabNames.length;++i)ctx.fillRect(this.x+this.tabX+(this.tabWidth+this.tabPadding)*i,this.y+this.tabY,70,15,"white"),ctx.fillText(`${this.tabNames[i]}`,this.x+this.tabX+(this.tabWidth+this.tabPadding)*(i+.4),this.y+this.tabY+this.tabHeight/2.7,.5,.5,12,"black");super.render(ctx)}}class VanishStateAI extends NamedStateAI{constructor(hideTime,showTime,intervalTime){super("vanish"),this.namedStates.vanish=new VanishState(hideTime,!0),this.namedStates.show=new ShowState(showTime),this.namedStates.interval=new VanishState(intervalTime,!1)}}class PGameoverState extends BaseState{apply(dt){return!0}}class PJumpingState extends BaseState{constructor(maxVelocityX,movePower){super(),this.maxVelocityX=maxVelocityX,this.movePower=movePower}apply(dt){let vx=0;return Input.key.isPressed(Input.key.left())&&(vx+=-1),Input.key.isPressed(Input.key.right())&&(vx+=1),0!==vx&&(this.entity.setDirection(vx),(this.entity.body.velocityX*vx<0||Math.abs(this.entity.body.velocityX)<Math.abs(this.maxVelocityX))&&this.entity.body.enforce(this.movePower*vx/dt,0)),Util.onGround(this.entity)&&(this.entity.body.isFixX?this.ai.changeState("stationary"):this.ai.changeState("walk")),!0}}class PJumpState extends BaseState{constructor(jumpPower){super(),this.inAirCount=0,this.jumpPressedTime=0,this.jumpDeltaTime=0,this.jumpPower=jumpPower,this.reservedVelocityX=0}init(){super.init(),this.inAirCount=0,this.jumpPressedTime=0,this.jumpDeltaTime=0,this.reservedVelocityX=this.entity.body.velocityX}apply(dt){return this.entity.body.setNextAddVelocity(-this.entity.body.velocityX/11,0),Input.key.isPressed(Input.key.up())&&(this.jumpPressedTime+=1),this.jumpDeltaTime+=1,Util.onGround(this.entity)?this.inAirCount=0:++this.inAirCount>5&&this.ai.changeState("stationary"),Util.canEnd(this.entity.getImage())&&0===this.inAirCount&&(this.entity.body.setNextAddVelocity(.8*this.reservedVelocityX-this.entity.body.velocityX,-this.entity.body.velocityY),this.entity.body.enforce(0,-this.jumpPower*this.entity.material.mass*1e3/dt*(this.jumpPressedTime+this.jumpDeltaTime)/2/this.jumpDeltaTime),this.ai.changeState("jumping")),!0}}class PPunchState extends BaseState{constructor(){super(),this.attacked=!1,this.threshold=.5}makeAttackObject(){const punch=this.entity.stage.addEntityByID(2e5,{x:this.entity.x+(1===this.entity.directionX?this.entity.width-22:-10),y:this.entity.y+27,z:this.entity.z+1,owner:this.entity});return punch}init(){super.init(),this.attacked=!1}apply(dt){if(Util.canEnd(this.entity.getImage())||!(this.entity.getImage().getAnimationCount()<this.threshold))return this.attacked||(this.makeAttackObject(),this.attacked=!0),Util.canEnd(this.entity.getImage())&&(this.entity.body.isFixX?this.ai.changeState("stationary"):this.ai.changeState("walk")),!0}}class PStationaryState extends BaseState{constructor(maxVelocityX,walkPower){super(),this.maxVelocityX=maxVelocityX,this.walkPower=walkPower}apply(dt){let vx=0;return Input.key.isPressed(Input.key.left())&&(vx+=-1),Input.key.isPressed(Input.key.right())&&(vx+=1),0!==vx&&(this.entity.setDirection(vx),(this.entity.body.velocityX*vx<0||Math.abs(this.entity.body.velocityX)<this.maxVelocityX)&&this.entity.body.enforce(vx*this.walkPower*this.entity.material.mass/dt,0),this.ai.changeState("walk")),Util.onGround(this.entity)&&(Input.key.isPressed(Input.key.up())&&this.ai.changeState("jump"),Input.key.isPress(Input.key.yes())&&this.ai.changeState("attack")),!0}}class PWalkState extends BaseState{constructor(maxVelocityX,walkPower){super(),this.maxVelocityX=maxVelocityX,this.walkPower=walkPower}apply(dt){let input=!1,vx=0;return Input.key.isPressed(Input.key.left())&&(vx+=-1,input=!0),Input.key.isPressed(Input.key.right())&&(vx+=1,input=!0),0!==vx&&(this.entity.setDirection(vx),(this.entity.body.velocityX*vx<0||Math.abs(this.entity.body.velocityX)<this.maxVelocityX)&&this.entity.body.enforce(vx*this.walkPower*this.entity.material.mass/dt,0)),input||this.ai.changeState("stationary"),Util.onGround(this.entity)&&(Input.key.isPressed(Input.key.up())&&this.ai.changeState("walkjump"),Input.key.isPress(Input.key.yes())&&this.ai.changeState("attack")),!0}}class AreaBackground extends ImageBackground{constructor(backImage,x,y,areaWidth,areaHeight){super(backImage),this.x=x,this.y=y,this.areaWidth=areaWidth,this.areaHeight=areaHeight}render(ctx,shiftX,shiftY,screenWidth,screenHeight){let x=-shiftX-this.x,y=-shiftY-this.y;const width=this.backImage.getWidth(),height=this.backImage.getHeight();x=x<=0?this.x+shiftX:this.areaWidth-screenWidth<=-shiftX-this.x?this.x+shiftX-width+this.areaWidth:-(screenWidth-width)/(this.areaWidth-screenWidth)*(shiftX+this.x),y=y<=0?this.y+shiftY:this.areaHeight-screenHeight<=-shiftY-this.y?this.y+shiftY-height+this.areaHeight:-(screenHeight-height)/(this.areaHeight-screenHeight)*(shiftY+this.y),this.backImage.render(ctx,x,y)}}class FixedBackground extends ImageBackground{constructor(backImage,x,y){super(backImage),this.x=x,this.y=y}render(ctx,shiftX,shiftY,screenWidth,screenHeight){this.backImage.render(ctx,this.x+shiftX,this.y+shiftY)}}class AIListedObject extends AutonomyEntity{constructor(){super(),this.ai=[]}addAI(ai,priority=-1){const index=priority<0?this.ai.length+priority+1:priority;this.ai.splice(index,0,ai),super.addAI(ai,priority)}removeAI(ai){const index=this.ai.indexOf(ai);-1!==index&&this.ai.splice(index,1)}updateAI(dt){for(const it of this.ai)it.update(dt)}applyAI(dt){for(const it of this.ai)if(it.apply(dt))break}}class Character extends AIListedObject{constructor(){super(),this.hp=0}setHP(hp){this.hp=hp}getHP(){return this.hp}damage(damage){this.hp-=damage,this.hp<=0&&this.destroy()}destroy(){this.stage.removeEntity(this)}}class Enemy extends Character{constructor(){super(),this.setHP(1),this.setDirection(1)}}class StateCharacter extends Character{constructor(){super(),this.state=null}applyAI(dt){for(const it of this.ai)if(it.apply(dt)){this.state=it instanceof StateAI?it.getState():null;break}}render(ctx,shiftX=0,shiftY=0){null!==this.state&&this.state.canRendering?this.state.render(ctx,shiftX,shiftY):super.render(ctx,shiftX,shiftY)}}class PossessedObject extends AIListedObject{constructor(){super(),this.owner=null}setOwner(owner){this.owner=owner}getOwner(){return this.owner}}class TileObject extends ImmutableEntity{}class CharacterBuilder extends TileBuilder{makeImage(image){return this.imageBuilder.build("chara",image)}makeBody(body){switch(body.type){case"MaxAdopt":return new MaxAdoptBody;case"Precise":return new PreciseBody;case"Player":return new PlayerBody;default:return null}}makeBodyMaterial(material){switch(material.type){case"Immutable":return new ImmutableRigidMaterial(material.k,material.frictionX,material.frictionY,material.g);case"Mutable":return new MutableRigidMaterial(material.k,material.frictionX,material.frictionY,material.g);default:return null}}makeAI(ai){switch(ai.type){case"EnemyAI":return new EnemyAI(this.makeAI(ai.ai));case"StraightAI":return new StraightAI(ai.mvx,ai.px);case"JumpAI":return new JumpAI(ai.jump);case"ElevatorAI":{const ret=new ElevatorAI(ai.velocity,ai.power);for(const it of ai.floors)ret.addPosition(it.x,it.y);return ret}case"VanishStateAI":return new VanishStateAI(ai.hide,ai.show,ai.interval);case"PlayerGameoverStateAI":return new PlayerGameoverStateAI;case"PlayerBaseStateAI":return new PlayerBaseStateAI;case"AttackObjectAI":return new AttackObjectAI;case"StraightAttackAI":return new StraightAttackAI(void 0===ai.vx?0:ai.vx,void 0===ai.vy?0:ai.vy,void 0===ai.px?0:ai.px,void 0===ai.py?0:ai.py);default:return null}}makeEntityBase(deploy,entity){switch(entity.type){case"OnlyImage":return new OnlyImageEntity;case"AIObject":return new AIListedObject;case"Character":return new Character;case"StateCharacter":return new StateCharacter;case"Player":return new Player;case"Enemy":return new Enemy;case"Obstacle":return new Obstacle;case"Door":{const ret=new DoorObject(deploy.stage,deploy.replace,deploy.pop),colliderData=this.trDyReplace(deploy,entity,"collider"),collider=this.makeCollider(colliderData);return collider.setAABB(this.makeAABB(colliderData)),ret.setCollider(collider),ret}case"Sign":{const ret=new SignObject,colliderData=this.tryReplace(deploy,entity,"collider"),collider=this.makeCollider(colliderData);collider.setAABB(this.makeAABB(colliderData)),ret.setCollider(collider);const signData=this.tryReplace(deploy,entity,"sign");return ret.setSign(this.imageBuilder.build("event",signData.image),signData.x,signData.y),ret}case"Event":{const once=this.tryReplace(deploy,entity,"once"),ret=once?new OnceEventEntity:new ImmutableEvent,colliderData=this.tryReplace(deploy,entity,"collider"),collider=this.makeCollider(colliderData);return collider.setAABB(this.makeAABB(colliderData)),ret.setCollider(collider),ret}case"Attack":return new AttackObject(this.tryReplace(deploy,entity,"lifespan"));default:return null}}buildBody(base,deploy,json){const bodyData=this.tryReplace(deploy,json,"body");base.setRigidBody(this.makeBody(bodyData)),null!==base.body&&(base.body.enable=void 0===bodyData.enable||bodyData.enable,base.body.setMaterial(this.makeBodyMaterial(bodyData.material)))}buildAI(base,deploy,json){const aiData=[];if(void 0!==json.ai)for(const it of json.ai)aiData.push(it);if(void 0!==deploy&&void 0!==deploy.ai)for(const it of deploy.ai){const index=aiData.findIndex(v=>v.type===it.type);if(index>=0)for(const item in it)it.hasOwnProperty(item)&&(aiData[index][item]=it[item]);else aiData.push(it)}for(const ai of aiData)base.addAI(this.makeAI(ai))}buildOwner(base,deploy,json){void 0!==deploy&&void 0!==deploy.owner&&base.setOwner(deploy.owner)}build(deploy,json){const base=this.makeEntityBase(deploy,json);return this.buildBase(base,deploy,json),BaseUtil.implementsOf(base,IOwned)&&this.buildOwner(base,deploy,json),base instanceof ImagedEntity&&this.buildImage(base,deploy,json),base instanceof InfluentialEntity&&this.buildPhysical(base,deploy,json),base instanceof MutableEntity&&this.buildBody(base,deploy,json),base instanceof AutonomyEntity&&this.buildAI(base,deploy,json),base}}class JointBody extends PreciseBody{constructor(jointingX,jointingY){super(),this.jointingX=jointingX,this.jointingY=jointingY,this.jointed=null,this.jointedX=0,this.jointedY=0,this.length=0}joint(jointed,jointedX,jointedY,length){this.jointed=jointed,this.jointedX=jointedX,this.jointedY=jointedY,this.length=length}unjoint(){this.jointed=null}updateVelocity(dt){null!==this.jointed?this.jointed instanceof MutableEntity?null!==this.jointed.body&&(this.material.velocityX=this.jointed.velocityX,this.material.velocityY=this.jointed.velocityY):(this.material.velocityX=0,this.material.velocityY=0):super.updateVelocity(dt)}updateEntity(dt){if(super.updateEntity(dt),null!==this.jointed){const ex=this.entity.directionX>=0?this.entity.x+this.jointingX:this.entity.x+this.entity.width-this.jointingX,ey=this.entity.directionY>0?this.entity.y+this.jointingY:this.entity.y+this.entity.height-this.jointingY,jx=this.jointed.directionX>=0?this.jointed.x+this.jointedX:this.jointed.x+this.jointed.width-this.jointedX,jy=this.jointed.directionY>0?this.jointed.y+this.jointedY:this.jointed.y+this.jointed.height-this.jointedY,dx=jx-ex,dy=jy-ey,d=Math.sqrt(dx*dx+dy*dy);if(d>this.length){const l=d-this.length;for(const it of this.entity.collider.collisions)(it.colliding===this.entity&&it.nx*dx>0||it.collided===this.entity&&it.nx*dx<0)&&(this.length<Math.abs(dx)&&(dy=dy*d/l+Math.sign(dy)),dx=0),(it.colliding===this.entity&&it.ny*dy>0||it.collided===this.entity&&it.ny*dy<0)&&(this.length<Math.abs(dy)&&(dx=dx*d/l+Math.sign(dx)),dy=0);this.entity.deltaMove(l*dx/d,l*dy/d)}}}}class DirectionalAABB extends SimpleAABB{update(startX,startY,endX,endY,entity){entity instanceof MutableEntity&&(entity.directionX>=0?(this.startXVal=entity.x+startX,this.endXVal=entity.x+endX):(this.startXVal=entity.width-endX+entity.x,this.endXVal=entity.width-startX+entity.x),entity.directionY<=0?(this.startYVal=entity.y+startY,this.endYVal=entity.y+endY):(this.startYVal=entity.height-endY+entity.y,this.endYVal=entity.height-startY+entity.y))}}class RecordedTimer extends SimpleTimer{constructor(){super(),this.elapsedTime=0,this.recordedTime={},this.maxTime={},this.minTime={},this.meanTime={}}update(dt){super.update(dt);for(const it in this.namedTimer)this.namedTimer.hasOwnProperty(it)&&(void 0===this.recordedTime[it]&&(this.recordedTime[it]=[]),this.recordedTime[it].push(this.namedTimer[it]));if(this.elapsedTime+=dt,this.elapsedTime>1e3){this.elapsedTime-=1e3;for(const it in this.recordedTime)if(this.recordedTime.hasOwnProperty(it)){this.maxTime[it]=0,this.minTime[it]=Number.MAX_SAFE_INTEGER,this.meanTime[it]=0;for(const e of this.recordedTime[it])this.maxTime[it]=Math.max(this.maxTime[it],e),this.minTime[it]=Math.min(this.minTime[it],e),this.meanTime[it]+=e;this.meanTime[it]=Math.floor(this.meanTime[it]/this.recordedTime[it].length),this.recordedTime[it].length=0}}}render(ctx,x,y){for(const name in this.namedTimer)if(this.namedTimer.hasOwnProperty(name)){const max=void 0===this.maxTime[name]?0:this.maxTime[name],min=void 0===this.minTime[name]?0:this.minTime[name],mean=void 0===this.meanTime[name]?0:this.meanTime[name];ctx.fillText(`${name} : ${max} - ${min} (${mean}) msec`,x,y,0,0,20,"white"),y+=30}}}class GameScene extends BaseLayeredScene{constructor(){super(),this.stageManager=null,this.eventManager=null,this.player=null,this.gameover=!1}init(){this.stageManager=new StackStageManager,this.stageManager.setStageParser(new UnderStageParser),this.stageManager.setStageSize(GameScreen.it.width,GameScreen.it.height),this.stageManager.pushStage("map1"),this.eventManager=new QueueEventManager,this.player=this.stageManager.getStage().getEntities().find(it=>BaseUtil.implementsOf(it,IPlayable)),this.clearLayer();const ui=new UILayer(this.stageManager.getStage());ui.setPosition(0,0),ui.setSize(GameScreen.it.width,GameScreen.it.height),this.addLayer(ui),this.gameover=!1}update(dt){if(this.player.isGameover()&&!this.gameover){const layer=new GameoverLayer;layer.setPosition(0,0,1),layer.setSize(GameScreen.it.width,GameScreen.it.height),this.addLayer(layer),this.gameover=!0}this.stageManager.update(dt),super.update(dt),this.gameover&&(Input.key.isPress(Input.key.yes())?this.init():Input.key.isPress(Input.key.no())&&SceneManager.it.replaceScene(new TitleScene)),this.eventManager.update(dt)}render(ctx){this.stageManager.render(ctx),super.render(ctx),this.eventManager.render(ctx)}}class CommonBaseStateAI extends TransferableStateAI{constructor(){super("none"),this.namedStates.none=new CpmmonJudgeState,this.namedStates.gameover=new CommonGameoverState}}class UnderPlayerState extends TransferableState{transitionUsualState(){Util.onGround(this.entity)?this.entity.body.isFixX?this.ai.changeState("stationary"):this.ai.changeState("walk"):this.ai.changeState("fall")}}class UnderStateAI extends TransferableStateAI{constructor(state){super(state),this.specialActionName="special"}changeState(state){return"special"===state&&(state=this.specialActionName),super.changeState(state)}}class WildRollingState extends UnderPlayerState{apply(dt){return Util.onGround(this.entity)&&(this.entity.body.setNextAddVelocity(-this.entity.body.velocityX,0),this.transitionUsualState()),!0}}class HeadHookingState extends HookingState{constructor(){super(),this.descentCount=0}apply(dt){super.apply(dt);const vx=Math.sign(this.entity.body.velocityX),vy=Math.sign(this.entity.body.velocityY);if(this.entity.setDirection(0===vx?void 0:vx,0===vy?void 0:vy),null===this.hook)return!0;if(vy>0&&this.descentCount++>=5){const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));if(hooks.length>=1)for(const it of hooks)it.getActor()===this.hook.getActor()&&it.release();return!0}for(const it of this.entity.collider.collisions){const dot=it.nx*this.entity.directionX+it.ny*this.entity.directionY;if(it.colliding===this.entity&&dot>0||it.collided===this.entity&&dot<0){const you=Util.getCollidedEntity(this.entity,it);if(!you.collider.isResponse(this.entity.collider)||!this.entity.collider.isResponse(you.collider))continue;if(BaseUtil.implementsOf(you,IHook)&&you.getActor()===this.hook.getActor())continue;this.hook.hooked(),this.ai.changeState("hooked");break}}return!0}}class HeadHookStateAI extends HookStateAI{constructor(){super(),this.namedStates.hooking=new HeadHookingState,this.namedStates.hooked=new NoneState}}class HookObject extends PossessedObject{constructor(){super(),this.previous=null,this.post=null,this.string=null,this.restLength=0,this.hookedLength=0,this.childID=0,this.generatedX=0,this.generatedY=0,this.isHooked=!1}getHookX(){}getHookY(){}setHookInfo(previous,string,restLength,hookedLength,childID){this.previous=previous,this.string=string,this.restLength=restLength,this.hookedLength=hookedLength,this.childID=childID}connectPlayer(){let x=this.generatedX,y=this.generatedY;this.owner instanceof MutableEntity&&(x=this.owner.directionX>=0?this.generatedX+this.owner.x+this.owner.width:this.owner.x-this.generatedX,y=this.owner.y-this.generatedY),this.post=new HookOwner,this.post.setPosition(x,y,this.z),this.post.setSize(8,8),this.post.setOwner(this.owner),this.post.setHookInfo(this,this.string,this.restLength-15,this.hookedLength,this.childID),this.post.init()}makeChild(vx,vy){if(this.restLength-15<=0)return void this.connectPlayer();let x=this.generatedX,y=this.generatedY;this.owner instanceof MutableEntity&&(x=this.owner.directionX>=0?this.generatedX+this.owner.x+this.owner.width:this.owner.x-this.generatedX,y=this.owner.y-this.generatedY);const dx=Math.abs(x-this.getHookX()),dy=Math.abs(y-this.getHookY()),d=Math.sqrt(dx*dx+dy*dy),l=this.string.getLength()+3;d>l&&(this.post=this.stage.addEntityByID(this.childID,{x:x,y:y,z:this.z,owner:this.owner}),this.post.setHookInfo(this,this.string,this.restLength-15,this.hookedLength,this.childID),this.post.body.setNextAddVelocity(vx,vy),this.string.addBody(this.post.body,this.post.directionX>=0?this.post.getHookX()-this.post.x:this.post.x+this.post.width-this.post.getHookX(),this.post.directionY>0?this.post.getHookY()-this.post.y:this.post.y+this.post.height-this.post.getHookY(),3),this.post.deltaMove(-dx*(d-l)/d,-dy*(d-l)/d),this.post.makeChild(vx,vy))}getActor(){return this.owner}createPost(){(this.isHead()||null!==this.previous)&&null===this.post&&(this.restLength<=0&&this.isHooked||this.makeChild(this.body.velocityX,this.body.velocityY))}hooked(){this.isHooked=!0,null!==this.post?this.post.hooked():this.connectPlayer(),this.restLength<this.hookedLength&&this.destroy()}release(){for(const it of this.ai)it instanceof StateAI&&it.changeState("released");!this.isHead()&&null===this.previous||null!==this.post||this.connectPlayer()}tryRemove(){return this.post instanceof HookOwner&&(this.destroy(),!0)}isHead(){return!1}destroy(){null!==this.previous&&(this.post.previous=this.previous,this.previous.post=this.post),this.previous=null,this.post=null,this.string.removeBody(this.body),this.stage.removeEntity(this)}init(){super.init(),this.generatedX=this.x,this.generatedY=this.y,this.owner instanceof MutableEntity&&(this.generatedX=this.owner.directionX>=0?this.x-this.owner.width-this.owner.x:this.owner.x-this.x,this.generatedY=this.owner.y-this.y)}render(ctx,shiftX=0,shiftY=0){if(super.render(ctx,shiftX,shiftY),null!==this.post)ctx.strokeLine(this.getHookX()+shiftX,this.getHookY()+shiftY,this.post.getHookX()+shiftX,this.post.getHookY()+shiftY,"#FFCC66",4);else if(this.owner instanceof MutableEntity){const x=this.owner.directionX>=0?this.generatedX+this.owner.x+this.owner.width:this.owner.x-this.generatedX,y=this.owner.y-this.generatedY;ctx.strokeLine(this.getHookX()+shiftX,this.getHookY()+shiftY,x+shiftX,y+shiftY,"#FFCC66",4)}}}class HookOwner extends HookObject{getHookX(){return this.owner instanceof MutableEntity?this.owner.directionX>=0?this.generatedX+this.owner.x+this.owner.width:this.owner.x-this.generatedX:this.x}getHookY(){return this.owner instanceof MutableEntity?this.owner.y-this.generatedY:this.y}hooked(){}release(){}destroy(){}init(){super.init(),this.owner instanceof MutableEntity&&this.string.addBody(this.owner.body,this.owner.width+this.generatedX,-this.generatedY,this.string.getLength())}}class IUnderPlayable extends IPlayable{changeType(id){}}class UnderTileObject extends TileObject{constructor(terrainID){super(),this.terrainID=terrainID}getTerrainID(){return this.terrainID}}class UnderCharacterBuilder extends CharacterBuilder{makeBody(body){switch(body.type){case"String":return new StringBody(this.makeBody(body.body),body.x,body.y,body.length,body.k,body.count);default:return super.makeBody(body)}}makeCollider(collider){if(collider.excluded)switch(collider.type){case"Rectangle":return new ExcludedRectangleCollider(collider.startX,collider.startY,collider.width,collider.height,collider.id);case"RoundRectangle":return new ExcludedRoundRectangleCollider(collider.startX,collider.startY,collider.width,collider.height,collider.cut,collider.id)}return super.makeCollider(collider)}makeAI(ai){switch(ai.type){case"CommonBaseStateAI":return new CommonBaseStateAI;case"NormalBaseStateAI":return new NormalBaseStateAI;case"WildBaseStateAI":return new WildBaseStateAI;case"AdventurerBaseStateAI":return new AdventurerBaseStateAI;case"PropellerBaseStateAI":return new PropellerBaseStateAI;case"HookStateAI":return new HookStateAI;case"HeadHookStateAI":return new HeadHookStateAI;default:return super.makeAI(ai)}}makeEntityBase(deploy,entity){switch(entity.type){case"Player":return new UnderPlayer;case"HookHead":return new HookHead(this.tryReplace(deploy,entity,"max"),this.tryReplace(deploy,entity,"hook"),this.tryReplace(deploy,entity,"child"));case"HookChild":return new HookChild;case"Sign":{const signData=this.tryReplace(deploy,entity,"sign");if(void 0!==signData.image)return super.makeEntityBase(deploy,entity);const ret=new TextSignObject,colliderData=this.tryReplace(deploy,entity,"collider"),collider=this.makeCollider(colliderData);return collider.setAABB(this.makeAABB(colliderData)),ret.setCollider(collider),ret.setSign(signData.x,signData.y,signData.size,signData.text),ret}default:return super.makeEntityBase(deploy,entity)}}}class IImageManager extends IResourceManager{getWidth(id){}getHeight(id){}getImage(id){}}class IMusicManager extends IResourceManager{getMusic(id){}}class ClipAnimation extends DelegateAnimation{setClipArea(clipX,clipY,clipWidth,clipHeight){for(const it of this.getImages())BaseUtil.implementsOf(it,IClipImage)&&it.setClipArea(clipX,clipY,clipWidth,clipHeight)}}class Player extends StateCharacter{constructor(){super(),this.setHP(3),this.setDirection(1),this.invincible=0}damage(damage){0===this.invincible&&this.hp>0&&(this.hp-=damage,this.invincible=1e3)}getCameraX(){return this.x+this.width/2}getCameraY(){return this.y+this.height/2}isGameover(){return this.getHP()<=0||this.stage.getStageHeight()<this.y}update(dt){this.invincible-=dt,this.invincible<=0&&(this.invincible=0),super.update(dt)}render(ctx,shiftX=0,shiftY=0){(this.invincible%2==0||this.hp<=0)&&super.render(ctx,shiftX,shiftY)}}class AttackObject extends PossessedObject{constructor(lifespan){super(),this.lifespan=lifespan}destroy(){this.stage.removeEntity(this)}update(dt){this.lifespan-=dt,this.lifespan<0?this.destroy():super.update(dt)}}class AdventurerHookState extends UnderPlayerState{init(){super.init();const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));if(hooks.length>=1){for(const it of hooks)it.getActor()===this.entity&&it.release();this.transitionUsualState()}}apply(dt){if(Util.canEnd(this.entity.getImage())){const hook=this.entity.stage.addEntityByID(200010,{x:this.entity.x+this.entity.width/2,y:this.entity.y+this.entity.height/2,z:this.entity.z-1,owner:this.entity});hook instanceof MutableEntity&&hook.body.enforce(12e5*this.entity.directionX/dt,-2e6/dt),this.transitionUsualState()}return!0}}class CommonGameoverState extends UnderPlayerState{init(){super.init(),this.entity.collider.fixBound(0,this.entity.height/2,this.entity.width,this.entity.height)}apply(dt){return!0}}class CpmmonJudgeState extends UnderPlayerState{constructor(){super(),this.damagedTarget=null}init(){super.init(),BaseUtil.implementsOf(this.entity,IDamagable)&&(this.damagedTarget=this.entity)}apply(dt){return null!==this.damagedTarget&&this.damagedTarget.getHP()<=0&&(this.ai.changeState("gameover"),!0)}}class NormalBaseStateAI extends UnderStateAI{constructor(){super("stationary"),this.specialActionName="pray",this.namedStates.stationary=new NormalStationaryState(300,36e3),this.namedStates.walk=new NormalWalkState(300,18e3),this.namedStates.jump=new NormalJumpState(240),this.namedStates.walkjump=new NormalJumpState(320),this.namedStates.jumping=new NormalJumpingState(225,12e3),this.namedStates.fall=new NormalFallState(225,12e3),this.namedStates.falling=new NormalFallState(225,12e3),this.namedStates.attack=new NormalPunchState,this.namedStates.grab=new NormalGrabState(100,3e4),this.namedStates.grabwalk=new NormalGrabState(100,15e3),this.namedStates.pray=new NormalSpecialState}}class NormalJumpState extends UnderPlayerState{constructor(jumpPower){super(),this.jumpPower=jumpPower,this.inAirCount=0,this.jumpPressedTime=0,this.jumpDeltaTime=0,this.animationMagnification=1,this.reservedVelocityX=0}set speedMagnification(val){this.animationMagnification=val}set appliedPower(val){this.jumpPower=val}get speedMagnification(){return this.animationMagnification}get appliedPower(){return this.jumpPower}init(){super.init(),this.inAirCount=0,this.jumpPressedTime=0,this.jumpDeltaTime=0,this.reservedVelocityX=this.entity.body.velocityX}update(dt){const image=this.entity.getImage();null!==image&&image.update(dt*(this.animationMagnification-1))}apply(dt){return this.entity.body.setNextAddVelocity(-this.entity.body.velocityX/11,0),Input.key.isPressed(Input.key.up())&&(this.jumpPressedTime+=1),this.jumpDeltaTime+=1,Util.onGround(this.entity)?this.inAirCount=0:++this.inAirCount>5&&this.ai.changeState("stationary"),Util.canEnd(this.entity.getImage())&&0===this.inAirCount&&(this.entity.body.setNextAddVelocity(.8*this.reservedVelocityX-this.entity.body.velocityX,-this.entity.body.velocityY),this.entity.body.enforce(0,-this.jumpPower*this.entity.material.mass*1e3/dt*(this.jumpPressedTime+this.jumpDeltaTime)/2/this.jumpDeltaTime),this.ai.changeState("jumping")),!0}}class NormalPunchState extends UnderPlayerState{constructor(){super(),this.attacked=!1,this.threshold=.5}makeAttackObject(){return this.entity.stage.addEntityByID(2e5,{x:this.entity.x+(1===this.entity.directionX?this.entity.width-22:-10),y:this.entity.y+27,z:this.entity.z+1,owner:this.entity})}init(){super.init(),this.attacked=!1}apply(dt){if(Util.canEnd(this.entity.getImage())||!(this.entity.getImage().getAnimationCount()<this.threshold))return this.attacked||(this.makeAttackObject(),this.attacked=!0),Util.canEnd(this.entity.getImage())&&(this.entity.body.isFixX?this.ai.changeState("stationary"):this.ai.changeState("walk")),!0}}class NormalSpecialState extends UnderPlayerState{apply(dt){return Input.key.isPressed(Input.key.sub())||this.transitionUsualState(),!0}}class PropellerBaseStateAI extends NormalBaseStateAI{constructor(){super(),this.specialActionName="none";for(const name in this.namedStates)if(this.namedStates.hasOwnProperty(name)){const state=this.namedStates[name];BaseUtil.implementsOf(state,IMovableState)&&(state.setMaxVelocity(7*state.maxVX/6,7*state.maxVY/6),state.setMovePower(7*state.movePX/6,7*state.movePY/6)),BaseUtil.implementsOf(state,IPrepareState)&&(state.appliedPower=2*state.appliedPower)}this.namedStates.jumping=new PropellerJumpingState(350,500,21e3,3e4)}}class UnderMovableState extends UnderPlayerState{constructor(maxVelocityX,maxVelocityY,movePowerX,movePowerY){super(),this.maxVelocityX=maxVelocityX,this.maxVelocityY=maxVelocityY,this.movePowerX=movePowerX,this.movePowerY=movePowerY}get maxVX(){return this.maxVelocityX}get maxVY(){return this.maxVelocityY}get movePX(){return this.movePowerX}get movePY(){return this.movePowerY}setMaxVelocity(maxVelocityX,maxVelocityY){this.maxVelocityX=maxVelocityX,this.maxVelocityY=maxVelocityY}setMovePower(movePowerX,movePowerY){this.movePowerX=movePowerX,this.movePowerY=movePowerY}moveX(vx,dt){this.entity.setDirection(0===vx?this.directionX:vx),(this.entity.body.velocityX*vx<0||Math.abs(this.entity.body.velocityX)<Math.abs(this.maxVelocityX))&&this.entity.body.enforce(this.movePowerX*this.entity.material.mass*vx/dt,0)}moveY(vy,dt){this.entity.setDirection(void 0,0===vy?this.directionY:vy),(this.entity.body.velocityY*vy<0||Math.abs(this.entity.body.velocityY)<Math.abs(this.maxVelocityY))&&this.entity.body.enforce(0,this.movePowerY*this.entity.material.mass*vy/dt)}moveByInput(dt){let moved=!1;if(this.movePowerX>0){let vx=0;Input.key.isPressed(Input.key.left())&&(vx+=-1),Input.key.isPressed(Input.key.right())&&(vx+=1),0!==vx&&(this.moveX(vx,dt),moved=!0)}if(this.movePowerY>0){let vy=0;Input.key.isPressed(Input.key.up())&&(vy+=-1),Input.key.isPressed(Input.key.down())&&(vy+=1),0!==vy&&(this.moveY(vy,dt),moved=!0)}return moved}}class WildBaseStateAI extends NormalBaseStateAI{constructor(){super(),this.specialActionName="roll";for(const name in this.namedStates)if(this.namedStates.hasOwnProperty(name)){const state=this.namedStates[name];BaseUtil.implementsOf(state,IMovableState)&&(state.setMaxVelocity(4*state.maxVX/3,4*state.maxVY/3),state.setMovePower(5*state.movePX/4,5*state.movePY/3)),BaseUtil.implementsOf(state,IPrepareState)&&(state.speedMagnification=5*state.speedMagnification,state.appliedPower=3*state.appliedPower/2)}this.namedStates.attack=new WildClawState,this.namedStates.roll=new WildRollState(88e4,24e4),this.namedStates.rolling=new WildRollingState}}class WildClawState extends NormalPunchState{makeAttackObject(){const attack=this.entity.stage.addEntityByID(200002,{x:this.entity.x+(1===this.entity.directionX?this.entity.width-22:-26),y:this.entity.y+8,z:this.entity.z+1,owner:this.entity});return attack instanceof MutableEntity&&attack.setDirection(this.entity.directionX),attack}update(dt){const image=this.entity.getImage();null!==image&&image.update(dt),super.update(dt)}}class WildRollState extends UnderMovableState{constructor(movePowerX,movePowerY){super(0,0,movePowerX,movePowerY)}init(){super.init(),this.entity.body.setNextAddVelocity(-this.entity.body.velocityX,0)}apply(dt){return Util.canEnd(this.entity.getImage())&&(this.entity.body.enforce(this.movePowerX*this.entity.material.mass*this.entity.directionX/dt,-this.movePowerY*this.entity.material.mass/dt),this.ai.changeState("rolling")),!0}}class UnderPlayer extends Player{constructor(){super(),this.aiType=null,this.preTerrain=1}addAI(ai,priority=-1){ai instanceof TransferableStateAI&&(this.aiType=ai),super.addAI(ai,priority)}changeType(id){if(this.preTerrain===id)return!1;let ai=null,fileName="";switch(id){case 0:ai=new WildBaseStateAI,fileName="wild.png",this.body.material.frictionY=0;break;case 1:ai=new NormalBaseStateAI,fileName="player.png",this.body.material.frictionY=0;break;case 2:ai=new AdventurerBaseStateAI,fileName="adventurer.png",this.body.material.frictionY=2;break;case 3:ai=new PropellerBaseStateAI,fileName="propeller.png",this.body.material.frictionY=0}return null!==ai&&this.aiType.constructor!==ai.constructor&&(this.image instanceof MultiAnimation&&this.image.setAllImageID(ResourceManager.image.load(`chara/${fileName}`)),this.aiType.transfer(ai),this.removeAI(this.aiType),this.addAI(ai),this.preTerrain=id,!0)}}class HookChild extends HookObject{getHookX(){return this.x+this.width/2}getHookY(){return this.y+this.height/2}init(){super.init(),this.setPosition(this.x+this.x-this.getHookX(),this.y+this.y-this.getHookY())}}class HookHead extends HookObject{constructor(restLength,hookedLength,childID){super(),this.originalBody=null,this.setHookInfo(null,null,restLength,hookedLength,childID)}getHookX(){return this.x+Math.abs(this.width)/2}getHookY(){return this.y+Math.abs(this.height)/2}hooked(){super.hooked(),this.originalBody.enable=!1}release(){super.release(),this.originalBody.enable=!0}isHead(){return!0}init(){if(super.init(),BaseUtil.implementsOf(this.body,IString)){this.string=this.body;const bodies=this.string.getBodies().filter(it=>it.getEntity()===this);this.originalBody=0===bodies.length?null:bodies[0]}this.owner instanceof MutableEntity&&(this.directionX=this.owner.directionX,this.directionY=-1),this.setPosition(this.x+this.x-this.getHookX(),this.y+this.y-this.getHookY())}}class AdventurerBaseStateAI extends NormalBaseStateAI{constructor(){super(),this.specialActionName="hook";for(const name in this.namedStates)if(this.namedStates.hasOwnProperty(name)){const state=this.namedStates[name];BaseUtil.implementsOf(state,IMovableState)&&(state.setMaxVelocity(7*state.maxVX/6,7*state.maxVY/6),state.setMovePower(7*state.movePX/6,7*state.movePY/6)),BaseUtil.implementsOf(state,IPrepareState)&&(state.speedMagnification=3*state.speedMagnification,state.appliedPower=5*state.appliedPower/4)}this.namedStates.stationary=new AdventurerStationaryState(350,42e3),this.namedStates.walk=new AdventurerWalkState(350,21e3),this.namedStates.grab=new AdventurerGrabState(110,3e4),this.namedStates.jumping=new AdventurerJumpingState(262.5,14e3),this.namedStates.fall=new AdventurerFallState(250,15e3),this.namedStates.falling=new AdventurerFallState(250,15e3),this.namedStates.hook=new AdventurerHookState,this.namedStates.downwall=new AdventurerDownWallState(250,15e3)}}class AdventurerDownWallState extends UnderMovableState{constructor(maxVelocityX,movePower){super(maxVelocityX,0,movePower,0),this.directionX=0,this.downWallCount=0}init(){super.init(),this.entity.setDirection(-Math.sign(this.entity.body.velocityX)),this.directionX=this.entity.directionX,this.downWallCount=0,this.entity.body.enforce(-1500*this.entity.material.mass*this.directionX,0)}apply(dt){let vx=0;if(Input.key.isPressed(Input.key.left())&&-1===this.directionX&&(vx+=-1),Input.key.isPressed(Input.key.right())&&1===this.directionX&&(vx+=1),0!==vx)return this.entity.body.enforce(this.movePowerX*this.entity.material.mass*vx/dt,0),this.ai.changeState("falling"),!0;if(Util.onGround(this.entity))return this.transitionUsualState(),!0;if(Input.key.isPress(Input.key.sub())){const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));if(hooks.length>=1)for(const it of hooks)it.getActor()===this.entity&&it.release();else{const hook=this.entity.stage.addEntityByID(200010,{x:this.entity.x+this.entity.width/2,y:this.entity.y+this.entity.height/2,z:this.entity.z-1,owner:this.entity});hook instanceof MutableEntity&&hook.body.enforce(9e5*this.entity.directionX/dt,-15e5/dt)}}this.entity.body.enforce(-3e4*this.entity.material.mass*this.directionX/dt,0),this.entity.setDirection(this.directionX);const collided=this.entity.collider.collisions.some(it=>Math.abs(it.nx)&&this.directionX*it.nx<0);return collided?this.downWallCount=0:++this.downWallCount>2&&(this.entity.body.enforce(9e4*this.entity.material.mass*this.directionX/dt,0),this.ai.changeState("falling")),!0}}class NormalFallState extends UnderMovableState{constructor(maxVelocityX,movePower){super(maxVelocityX,0,movePower,0)}apply(dt){return this.moveByInput(dt),Util.canEnd(this.entity.getImage())&&this.ai.changeState("falling"),Util.onGround(this.entity)&&this.transitionUsualState(),!0}}class NormalGrabState extends UnderMovableState{constructor(maxVelocityX,walkPower){super(maxVelocityX,0,walkPower,0),this.underCount=0,this.underDiffY=12,this.player=null}changed(){this.restoreCollider()}grabCollider(){const aabb=this.entity.collider.getAABB();this.entity.collider.fixBound(aabb.startX-this.entity.x,aabb.startY+this.underDiffY-this.entity.y,aabb.endX-this.entity.x,aabb.endY-this.entity.y)}restoreCollider(){const aabb=this.entity.collider.getAABB();this.entity.collider.fixBound(aabb.startX-this.entity.x,aabb.startY-this.underDiffY-this.entity.y,aabb.endX-this.entity.x,aabb.endY-this.entity.y)}judgeContinue(){if(++this.underCount<=5)return!0;this.restoreCollider();const check=this.entity.stage.getPhysicalWorld().getCollisionData(this.entity.collider).some(it=>it.collided.collider.isResponse(this.entity)&&it.ny<-.5);return check?(this.grabCollider(),!0):(this.entity.image.init(),this.transitionUsualState(),!1)}grabWalk(dt){const moved=this.moveByInput(dt);moved?(this.entity.getImage()instanceof GameAnimation&&this.entity.getImage().restore(),"grab"===this.ai.getStateID()&&this.entity.image.init(),this.ai.changeState("grabwalk")&&this.restoreCollider()):this.entity.getImage()instanceof GameAnimation&&this.entity.getImage().pause()}init(){const image=this.entity.getImage();image instanceof NamedAnimation&&image.setName(this.ai.getStateID()),image instanceof GameAnimation&&image.restore(),this.underCount=0,this.grabCollider(),BaseUtil.implementsOf(this.entity,IUnderPlayable)&&(this.player=this.entity)}apply(dt){const image=this.entity.getImage(),canGrabAction=!(image instanceof GameAnimation)||image.isEnded()||image.isLoop();if(Util.onGround(this.entity)&&Input.key.isPressed(Input.key.down()))this.underCount=0;else if(!this.judgeContinue())return!0;if(canGrabAction&&Util.onGround(this.entity)&&this.grabWalk(dt),canGrabAction&&Util.onGround(this.entity)){const ground=Util.getUnderEntity(this.entity);if(BaseUtil.implementsOf(ground,ITerrain)&&this.player.changeType(ground.getTerrainID()))return this.changed(),!0}return!0}}class NormalJumpingState extends UnderMovableState{constructor(maxVelocityX,movePower){super(maxVelocityX,0,movePower,0)}apply(dt){return this.moveByInput(dt),this.entity.body.velocityY>0&&this.ai.changeState("fall"),Util.onGround(this.entity)&&this.transitionUsualState(),!0}}class NormalStationaryState extends UnderMovableState{constructor(maxVelocityX,walkPower){super(maxVelocityX,0,walkPower,0),this.fallCount=0}init(){super.init(),this.fallCount=0}apply(dt){const moved=this.moveByInput(dt);return moved&&this.ai.changeState("walk"),Util.onGround(this.entity)?(Input.key.isPressed(Input.key.down())&&this.ai.changeState("grab"),Input.key.isPressed(Input.key.up())&&(moved?this.ai.changeState("walkjump"):this.ai.changeState("jump")),Input.key.isPress(Input.key.yes())&&this.ai.changeState("attack"),Input.key.isPress(Input.key.sub())&&this.ai.changeState("special"),this.fallCount=0):++this.fallCount>2&&this.ai.changeState("fall"),!0}}class NormalWalkState extends UnderMovableState{constructor(maxVelocityX,walkPower){super(maxVelocityX,0,walkPower,0),this.fallCount=0}init(){super.init(),this.fallCount=0}apply(dt){const input=this.moveByInput(dt);return input||this.ai.changeState("stationary"),Util.onGround(this.entity)?(Input.key.isPressed(Input.key.down())&&this.ai.changeState("grab"),Input.key.isPressed(Input.key.up())&&this.ai.changeState("walkjump"),Input.key.isPress(Input.key.yes())&&this.ai.changeState("attack"),Input.key.isPress(Input.key.sub())&&this.ai.changeState("special"),this.fallCount=0):++this.fallCount>2&&this.ai.changeState("fall"),!0}}class PropellerJumpingState extends UnderMovableState{constructor(maxVelocityX,maxVelocityY,movePowerX,movePowerY){super(maxVelocityX,maxVelocityY,movePowerX,movePowerY),this.propellerDiffY=8}moveY(vy,dt){if(this.entity.body.velocityY*vy<0||Math.abs(this.entity.body.velocityY)<Math.abs(this.maxVelocityY)){const power=1===vy?this.movePowerY/10:this.movePowerY;this.entity.body.enforce(0,power*this.entity.material.mass*vy/dt)}}init(){super.init(),this.entity.getImage()instanceof GameAnimation&&this.entity.getImage().restore();const aabb=this.entity.collider.getAABB();this.entity.collider.fixBound(aabb.startX-this.entity.x,aabb.startY-this.propellerDiffY-this.entity.y,aabb.endX-this.entity.x,aabb.endY-this.entity.y)}update(dt){super.update(dt),null!==this.entity.getImage()&&this.entity.getImage().update(3*dt)}apply(dt){if(this.moveByInput(dt),Util.onGround(this.entity)){this.transitionUsualState();const aabb=this.entity.collider.getAABB();this.entity.collider.fixBound(aabb.startX-this.entity.x,aabb.startY+this.propellerDiffY-this.entity.y,aabb.endX-this.entity.x,aabb.endY-this.entity.y)}return!0}}class AdventurerFallState extends NormalFallState{apply(dt){let vx=0;if(Input.key.isPressed(Input.key.left())&&(vx+=-1),Input.key.isPressed(Input.key.right())&&(vx+=1),0!==vx)for(const it of this.entity.collider.collisions)if(Math.abs(it.nx)>.5&&vx*it.nx>0&&it.colliding.collider.isResponse(it.collided.collider)&&it.collided.collider.isResponse(it.colliding.collider))return this.ai.changeState("downwall"),this.entity.body.enforce(this.movePowerX*this.entity.material.mass*vx/dt,0),!0;if(Input.key.isPressed(Input.key.up()))for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(BaseUtil.implementsOf(you,IHook)&&!you.isHead()&&you.getActor()===this.entity&&you.tryRemove())return!0}if(Input.key.isPress(Input.key.sub())){const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));if(hooks.length>=1)for(const it of hooks)it.getActor()===this.entity&&it.release()}return super.apply(dt)}}class AdventurerGrabState extends NormalGrabState{changed(){super.changed();const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));for(const it of hooks)it.getActor()===this.entity&&it.release()}}class AdventurerJumpingState extends NormalJumpingState{apply(dt){if(Input.key.isPressed(Input.key.up()))for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(BaseUtil.implementsOf(you,IHook)&&!you.isHead()&&you.getActor()===this.entity&&you.tryRemove())return!0}if(Input.key.isPress(Input.key.sub())){const hooks=this.entity.stage.getEntities().filter(it=>BaseUtil.implementsOf(it,IHook));if(hooks.length>=1)for(const it of hooks)it.getActor()===this.entity&&it.release()}return super.apply(dt)}}class AdventurerStationaryState extends NormalStationaryState{apply(dt){if(Input.key.isPressed(Input.key.up()))for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(BaseUtil.implementsOf(you,IHook)&&!you.isHead()&&you.getActor()===this.entity&&you.tryRemove())return!0}return super.apply(dt)}}class AdventurerWalkState extends NormalWalkState{apply(dt){if(Input.key.isPressed(Input.key.up()))for(const it of this.entity.collider.collisions){const you=Util.getCollidedEntity(this.entity,it);if(BaseUtil.implementsOf(you,IHook)&&!you.isHead()&&you.getActor()===this.entity&&you.tryRemove())return!0}return super.apply(dt)}}(new MainBuilder).build().execute(new TitleScene);